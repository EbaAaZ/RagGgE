{"version":3,"file":"index.esm.js","sources":["../src/tvm/compact.ts","../src/tvm/ctypes.ts","../src/tvm/support.ts","../src/tvm/environment.ts","../src/tvm/memory.ts","../src/tvm/webgpu.ts","../src/tvm/runtime.ts","../src/model/llm.ts"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/** NodeJS and Web compact layer */\n\n/**\n * Get performance measurement.\n */\nexport function getPerformance(): Performance {\n  return performance;\n}\n\n/**\n * Create a new websocket for a given URL\n * @param url The url.\n */\nexport function createWebSocket(url: string): WebSocket {\n  return new WebSocket(url);\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * Types for C API.\n */\n\n/** A pointer to points to the raw address space. */\nexport type Pointer = number;\n\n/** A pointer offset, need to add a base address to get a valid ptr. */\nexport type PtrOffset = number;\n\n// -- TVM runtime C API --\n/**\n * const char *TVMGetLastError();\n */\nexport type FTVMGetLastError = () => Pointer;\n\n/**\n * int TVMModGetFunction(TVMModuleHandle mod,\n *                       const char* func_name,\n *                       int query_imports,\n *                       TVMFunctionHandle *out);\n */\nexport type FTVMModGetFunction = (\n  mod: Pointer, funcName: Pointer, queryImports: number, out: Pointer) => number;\n/**\n * int TVMModImport(TVMModuleHandle mod,\n *                  TVMModuleHandle dep);\n */\nexport type FTVMModImport = (mod: Pointer, dep: Pointer) => number;\n\n/**\n * int TVMModFree(TVMModuleHandle mod);\n */\nexport type FTVMModFree = (mod: Pointer) => number;\n\n/**\n * int TVMFuncFree(TVMFunctionHandle func);\n */\nexport type FTVMFuncFree = (func: Pointer) => number;\n\n/**\n * int TVMFuncCall(TVMFunctionHandle func,\n *                 TVMValue* arg_values,\n *                 int* type_codes,\n *                 int num_args,\n *                 TVMValue* ret_val,\n *                 int* ret_type_code);\n */\nexport type FTVMFuncCall = (\n  func: Pointer, argValues: Pointer, typeCode: Pointer,\n  nargs: number, retValue: Pointer, retCode: Pointer) => number;\n\n/**\n * int TVMCFuncSetReturn(TVMRetValueHandle ret,\n *                       TVMValue* value,\n *                       int* type_code,\n *                       int num_ret);\n */\nexport type FTVMCFuncSetReturn = (\n  ret: Pointer, value: Pointer, typeCode: Pointer, numRet: number) => number;\n\n/**\n * int TVMCbArgToReturn(TVMValue* value, int* code);\n */\nexport type FTVMCbArgToReturn = (value: Pointer, code: Pointer) => number;\n\n/**\n * int TVMFuncListGlobalNames(int* outSize, const char*** outArray);\n */\nexport type FTVMFuncListGlobalNames = (outSize: Pointer, outArray: Pointer) => number;\n\n/**\n * int TVMFuncRegisterGlobal(\n *    const char* name, TVMFunctionHandle f, int override);\n */\nexport type FTVMFuncRegisterGlobal = (\n  name: Pointer, f: Pointer, override: number) => number;\n\n/**\n *int TVMFuncGetGlobal(const char* name, TVMFunctionHandle* out);\n    */\nexport type FTVMFuncGetGlobal = (name: Pointer, out: Pointer) => number;\n\n/**\n * int TVMArrayAlloc(const tvm_index_t* shape,\n *                   int ndim,\n *                   int dtype_code,\n *                   int dtype_bits,\n *                   int dtype_lanes,\n *                   int device_type,\n *                   int device_id,\n *                   TVMArrayHandle* out);\n */\nexport type FTVMArrayAlloc = (\n  shape: Pointer, ndim: number,\n  dtypeCode: number, dtypeBits: number,\n  dtypeLanes: number, deviceType: number, deviceId: number,\n  out: Pointer) => number;\n\n/**\n * int TVMArrayFree(TVMArrayHandle handle);\n */\nexport type FTVMArrayFree = (handle: Pointer) => number;\n\n/**\n * int TVMArrayCopyFromBytes(TVMArrayHandle handle,\n *                           void* data,\n *                           size_t nbytes);\n */\nexport type FTVMArrayCopyFromBytes = (\n  handle: Pointer, data: Pointer, nbytes: number) => number;\n\n/**\n * int TVMArrayCopyToBytes(TVMArrayHandle handle,\n *                         void* data,\n *                         size_t nbytes);\n */\nexport type FTVMArrayCopyToBytes = (\n  handle: Pointer, data: Pointer, nbytes: number) => number;\n\n/**\n * int TVMArrayCopyFromTo(TVMArrayHandle from,\n *                        TVMArrayHandle to,\n *                        TVMStreamHandle stream);\n */\nexport type FTVMArrayCopyFromTo = (\n  from: Pointer, to: Pointer, stream: Pointer) => number;\n\n/**\n * int TVMSynchronize(int device_type, int device_id, TVMStreamHandle stream);\n */\nexport type FTVMSynchronize = (\n  deviceType: number, deviceId: number, stream: Pointer) => number;\n\n/**\n * typedef int (*TVMBackendPackedCFunc)(TVMValue* args,\n *                                      int* type_codes,\n *                                      int num_args,\n *                                      TVMValue* out_ret_value,\n *                                      int* out_ret_tcode);\n */\nexport type FTVMBackendPackedCFunc = (\n  argValues: Pointer, argCodes: Pointer, nargs: number,\n  outValue: Pointer, outCode: Pointer) => number;\n\n\n/**\n * int TVMObjectFree(TVMObjectHandle obj);\n */\n export type FTVMObjectFree = (obj: Pointer) => number;\n\n/**\n * int TVMObjectGetTypeIndex(TVMObjectHandle obj, unsigned* out_tindex);\n */\nexport type FTVMObjectGetTypeIndex = (obj: Pointer, out_tindex: Pointer) => number;\n\n/**\n * int TVMObjectTypeIndex2Key(unsigned tindex, char** out_type_key);\n */\nexport type FTVMObjectTypeIndex2Key = (type_index: number, out_type_key: Pointer) => number;\n\n/**\n * int TVMObjectTypeKey2Index(const char* type_key, unsigned* out_tindex);\n */\nexport type FTVMObjectTypeKey2Index = (type_key: Pointer, out_tindex: Pointer) => number;\n\n// -- TVM Wasm Auxiliary C API --\n\n/** void* TVMWasmAllocSpace(int size); */\nexport type FTVMWasmAllocSpace = (size: number) => Pointer;\n\n/** void TVMWasmFreeSpace(void* data); */\nexport type FTVMWasmFreeSpace = (ptr: Pointer) => void;\n\n/**\n * int TVMWasmPackedCFunc(TVMValue* args,\n *                        int* type_codes,\n *                        int num_args,\n *                        TVMRetValueHandle ret,\n *                        void* resource_handle);\n */\nexport type FTVMWasmPackedCFunc = (\n  args: Pointer, typeCodes: Pointer, nargs: number,\n  ret: Pointer, resourceHandle: Pointer) => number;\n\n/**\n * int TVMWasmFuncCreateFromCFunc(void* resource_handle,\n *                                TVMFunctionHandle *out);\n */\nexport type FTVMWasmFuncCreateFromCFunc = (\n  resource: Pointer, out: Pointer) => number;\n\n/**\n * void TVMWasmPackedCFuncFinalizer(void* resource_handle);\n */\nexport type FTVMWasmPackedCFuncFinalizer = (resourceHandle: Pointer) => void;\n\n/**\n * Size of common data types.\n */\nexport const enum SizeOf {\n  U8 = 1,\n  U16 = 2,\n  I32 = 4,\n  I64 = 8,\n  F32 = 4,\n  F64 = 8,\n  TVMValue = 8,\n  DLDataType = I32,\n  DLDevice = I32 + I32,\n}\n\n/**\n * Argument Type code in TVM FFI.\n */\nexport const enum ArgTypeCode {\n  Int = 0,\n  UInt = 1,\n  Float = 2,\n  TVMOpaqueHandle = 3,\n  Null = 4,\n  TVMDataType = 5,\n  DLDevice = 6,\n  TVMDLTensorHandle = 7,\n  TVMObjectHandle = 8,\n  TVMModuleHandle = 9,\n  TVMPackedFuncHandle = 10,\n  TVMStr = 11,\n  TVMBytes = 12,\n  TVMNDArrayHandle = 13,\n  TVMObjectRValueRefArg = 14\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * Convert string to Uint8array.\n * @param str The string.\n * @returns The corresponding Uint8Array.\n */\nexport function StringToUint8Array(str: string): Uint8Array {\n  const arr = new Uint8Array(str.length + 1);\n  for (let i = 0; i < str.length; ++i) {\n    arr[i] = str.charCodeAt(i);\n  }\n  arr[str.length] = 0;\n  return arr;\n}\n\n/**\n * Convert Uint8array to string.\n * @param array The array.\n * @returns The corresponding string.\n */\nexport function Uint8ArrayToString(arr: Uint8Array): string {\n  const ret = [];\n  for (const ch of Array.from(arr)) {\n    ret.push(String.fromCharCode(ch));\n  }\n  return ret.join(\"\");\n}\n\n/**\n * Internal assert helper\n * @param condition condition The condition to fail.\n * @param msg msg The message.\n */\nexport function assert(condition: boolean, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(\"AssertError:\" + (msg || \"\"));\n  }\n}\n\n/**\n * Get the path to the wasm library in nodejs.\n * @return The wasm path.\n */\nexport function wasmPath(): string {\n  return \".\"\n  // return __dirname + \"/wasm\";\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/**\n * Runtime environment that provide js libaries calls.\n */\nimport { Pointer } from \"./ctypes\";\nimport { LibraryProvider } from \"./types\";\nimport { assert } from \"./support\";\nimport * as ctypes from \"./ctypes\";\n\n/**\n * Detect library provider from the importObject.\n *\n * @param importObject The import object.\n */\nfunction detectLibraryProvider(\n  importObject: Record<string, any>\n): LibraryProvider | undefined {\n  if (\n    importObject[\"wasmLibraryProvider\"] &&\n    importObject[\"wasmLibraryProvider\"][\"start\"] &&\n    importObject[\"wasmLibraryProvider\"][\"imports\"] !== undefined\n  ) {\n    const item = importObject as { wasmLibraryProvider: LibraryProvider };\n    // create provider so that we capture imports in the provider.\n    return {\n      imports: item.wasmLibraryProvider.imports,\n      start: (inst: WebAssembly.Instance): void => {\n        item.wasmLibraryProvider.start(inst);\n      },\n    };\n  } else if (importObject[\"imports\"] && importObject[\"start\"] !== undefined) {\n    return importObject as LibraryProvider;\n  } else if (importObject[\"wasiImport\"] && importObject[\"start\"] !== undefined) {\n    // WASI\n    return {\n      imports: {\n        \"wasi_snapshot_preview1\": importObject[\"wasiImport\"],\n      },\n      start: (inst: WebAssembly.Instance): void => {\n        importObject[\"start\"](inst);\n      }\n    };\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Environment to impelement most of the JS library functions.\n */\nexport class Environment implements LibraryProvider {\n  logger: (msg: string) => void;\n  imports: Record<string, any>;\n  /**\n   * Maintains a table of FTVMWasmPackedCFunc that the C part\n   * can call via TVMWasmPackedCFunc.\n   *\n   * We maintain a separate table so that we can have un-limited amount\n   * of functions that do not maps to the address space.\n   */\n  packedCFuncTable: Array<ctypes.FTVMWasmPackedCFunc | undefined> = [\n    undefined,\n  ];\n  /**\n   * Free table index that can be recycled.\n   */\n  packedCFuncTableFreeId: Array<number> = [];\n\n  private libProvider?: LibraryProvider;\n\n  constructor(\n    importObject: Record<string, any> = {},\n    logger: (msg: string) => void = console.log\n  ) {\n    this.logger = logger;\n    this.libProvider = detectLibraryProvider(importObject);\n    // get imports from the provider\n    if (this.libProvider !== undefined) {\n      this.imports = this.libProvider.imports;\n    } else {\n      this.imports = importObject;\n    }\n    // update with more functions\n    this.imports.env = this.environment(this.imports.env);\n  }\n\n  /** Mark the start of the instance. */\n  start(inst: WebAssembly.Instance): void {\n    if (this.libProvider !== undefined) {\n      this.libProvider.start(inst);\n    }\n  }\n\n  private environment(initEnv: Record<string, any>): Record<string, any> {\n    // default env can be be overriden by libraries.\n    const defaultEnv = {\n      \"__cxa_thread_atexit\": (): void => {},\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      \"emscripten_notify_memory_growth\": (index: number): void => {}\n    };\n    const wasmPackedCFunc: ctypes.FTVMWasmPackedCFunc = (\n      args: Pointer,\n      typeCodes: Pointer,\n      nargs: number,\n      ret: Pointer,\n      resourceHandle: Pointer\n    ): number => {\n      const cfunc = this.packedCFuncTable[resourceHandle];\n      assert(cfunc !== undefined);\n      return cfunc(args, typeCodes, nargs, ret, resourceHandle);\n    };\n\n    const wasmPackedCFuncFinalizer: ctypes.FTVMWasmPackedCFuncFinalizer = (\n      resourceHandle: Pointer\n    ): void => {\n      this.packedCFuncTable[resourceHandle] = undefined;\n      this.packedCFuncTableFreeId.push(resourceHandle);\n    };\n\n    const newEnv = {\n      TVMWasmPackedCFunc: wasmPackedCFunc,\n      TVMWasmPackedCFuncFinalizer: wasmPackedCFuncFinalizer,\n      \"__console_log\": (msg: string): void => {\n        this.logger(msg);\n      }\n    };\n    return Object.assign(defaultEnv, initEnv, newEnv);\n  }\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/**\n * Classes to manipulate Wasm memories.\n */\nimport { Pointer, PtrOffset, SizeOf } from \"./ctypes\";\nimport { Disposable } from \"./types\";\nimport { assert, StringToUint8Array } from \"./support\";\n\nimport * as ctypes from \"./ctypes\";\n\n/**\n * Wasm Memory wrapper to perform JS side raw memory access.\n */\nexport class Memory {\n  memory: WebAssembly.Memory;\n  wasm32 = true;\n  private buffer: ArrayBuffer | SharedArrayBuffer;\n  private viewU8: Uint8Array;\n  private viewU16: Uint16Array;\n  private viewI32: Int32Array;\n  private viewU32: Uint32Array;\n  private viewF32: Float32Array;\n  private viewF64: Float64Array;\n\n  constructor(memory: WebAssembly.Memory) {\n    this.memory = memory;\n    this.buffer = this.memory.buffer;\n    this.viewU8 = new Uint8Array(this.buffer);\n    this.viewU16 = new Uint16Array(this.buffer);\n    this.viewI32 = new Int32Array(this.buffer);\n    this.viewU32 = new Uint32Array(this.buffer);\n    this.viewF32 = new Float32Array(this.buffer);\n    this.viewF64 = new Float64Array(this.buffer);\n  }\n\n  loadU8(ptr: Pointer): number {\n    if (this.buffer != this.memory.buffer) {\n      this.updateViews();\n    }\n    return this.viewU8[ptr >> 0];\n  }\n\n  loadU16(ptr: Pointer): number {\n    if (this.buffer != this.memory.buffer) {\n      this.updateViews();\n    }\n    return this.viewU16[ptr >> 1];\n  }\n\n  loadU32(ptr: Pointer): number {\n    if (this.buffer != this.memory.buffer) {\n      this.updateViews();\n    }\n    return this.viewU32[ptr >> 2];\n  }\n\n  loadI32(ptr: Pointer): number {\n    if (this.buffer != this.memory.buffer) {\n      this.updateViews();\n    }\n    return this.viewI32[ptr >> 2];\n  }\n\n  loadI64(ptr: Pointer): number {\n    if (this.buffer != this.memory.buffer) {\n      this.updateViews();\n    }\n    const base = ptr >> 2;\n    // assumes little endian, for now truncate high.\n    return this.viewI32[base];\n  }\n\n  loadF32(ptr: Pointer): number {\n    if (this.buffer != this.memory.buffer) {\n      this.updateViews();\n    }\n    return this.viewF32[ptr >> 2];\n  }\n\n  loadF64(ptr: Pointer): number {\n    if (this.buffer != this.memory.buffer) {\n      this.updateViews();\n    }\n    return this.viewF64[ptr >> 3];\n  }\n\n  loadPointer(ptr: Pointer): Pointer {\n    if (this.buffer != this.memory.buffer) {\n      this.updateViews();\n    }\n    if (this.wasm32) {\n      return this.loadU32(ptr);\n    } else {\n      return this.loadI64(ptr);\n    }\n  }\n  loadUSize(ptr: Pointer): Pointer {\n    if (this.buffer != this.memory.buffer) {\n      this.updateViews();\n    }\n    if (this.wasm32) {\n      return this.loadU32(ptr);\n    } else {\n      return this.loadI64(ptr);\n    }\n  }\n  sizeofPtr(): number {\n    return this.wasm32 ? SizeOf.I32 : SizeOf.I64;\n  }\n  /**\n   * Load raw bytes from ptr.\n   * @param ptr The head address\n   * @param numBytes The number\n   */\n  loadRawBytes(ptr: Pointer, numBytes: number): Uint8Array {\n    if (this.buffer != this.memory.buffer) {\n      this.updateViews();\n    }\n    const result = new Uint8Array(numBytes);\n    result.set(this.viewU8.slice(ptr, ptr + numBytes));\n    return result;\n  }\n  /**\n   * Load TVMByteArray from ptr.\n   *\n   * @param ptr The address of the header.\n   */\n  loadTVMBytes(ptr: Pointer): Uint8Array {\n    const data = this.loadPointer(ptr);\n    const length = this.loadUSize(ptr + this.sizeofPtr());\n    return this.loadRawBytes(data, length);\n  }\n  /**\n   * Load null-terminated C-string from ptr.\n   * @param ptr The head address\n   */\n  loadCString(ptr: Pointer): string {\n    if (this.buffer != this.memory.buffer) {\n      this.updateViews();\n    }\n    // NOTE: the views are still valid for read.\n    const ret = [];\n    let ch = 1;\n    while (ch != 0) {\n      ch = this.viewU8[ptr];\n      if (ch != 0) {\n        ret.push(String.fromCharCode(ch));\n      }\n      ++ptr;\n    }\n    return ret.join(\"\");\n  }\n  /**\n   * Store raw bytes to the ptr.\n   * @param ptr The head address.\n   * @param bytes The bytes content.\n   */\n  storeRawBytes(ptr: Pointer, bytes: Uint8Array): void {\n    if (this.buffer != this.memory.buffer) {\n      this.updateViews();\n    }\n    this.viewU8.set(bytes, ptr);\n  }\n\n  /**\n   * Update memory view after the memory growth.\n   */\n  private updateViews(): void {\n    this.buffer = this.memory.buffer;\n    this.viewU8 = new Uint8Array(this.buffer);\n    this.viewU16 = new Uint16Array(this.buffer);\n    this.viewI32 = new Int32Array(this.buffer);\n    this.viewU32 = new Uint32Array(this.buffer);\n    this.viewF32 = new Float32Array(this.buffer);\n    this.viewF64 = new Float64Array(this.buffer);\n  }\n}\n\n/**\n * Auxiliary call stack for the FFI calls.\n *\n * Lifecyle of a call stack.\n * - Calls into allocXX to allocate space, mixed with storeXXX to store data.\n * - Calls into ptrFromOffset, no further allocation(as ptrFromOffset can change),\n *   can still call into storeXX\n * - Calls into commitToWasmMemory once.\n * - reset.\n */\nexport class CachedCallStack implements Disposable {\n  /** List of temporay arguments that can be disposed during reset. */\n  tempArgs: Array<Disposable> = [];\n\n  private memory: Memory;\n  private cAllocSpace: ctypes.FTVMWasmAllocSpace;\n  private cFreeSpace: ctypes.FTVMWasmFreeSpace;\n\n  private buffer: ArrayBuffer;\n  private viewU8: Uint8Array;\n  private viewI32: Int32Array;\n  private viewU32: Uint32Array;\n  private viewF64: Float64Array;\n\n  private stackTop: PtrOffset = 0;\n  private basePtr: Pointer = 0;\n\n  private addressToSetTargetValue: Array<[PtrOffset, PtrOffset]> = [];\n\n  constructor(\n    memory: Memory,\n    allocSpace: ctypes.FTVMWasmAllocSpace,\n    freeSpace: ctypes.FTVMWasmFreeSpace\n  ) {\n    const initCallStackSize = 128;\n    this.memory = memory;\n    this.cAllocSpace = allocSpace;\n    this.cFreeSpace = freeSpace;\n    this.buffer = new ArrayBuffer(initCallStackSize);\n    this.basePtr = this.cAllocSpace(initCallStackSize);\n    this.viewU8 = new Uint8Array(this.buffer);\n    this.viewI32 = new Int32Array(this.buffer);\n    this.viewU32 = new Uint32Array(this.buffer);\n    this.viewF64 = new Float64Array(this.buffer);\n    this.updateViews();\n  }\n\n  dispose(): void {\n    if (this.basePtr != 0) {\n      this.cFreeSpace(this.basePtr);\n      this.basePtr = 0;\n    }\n  }\n  /**\n   * Rest the call stack so that it can be reused again.\n   */\n  reset(): void {\n    this.stackTop = 0;\n    assert(this.addressToSetTargetValue.length == 0);\n    while (this.tempArgs.length != 0) {\n      (this.tempArgs.pop() as Disposable).dispose();\n    }\n  }\n\n  /**\n   * Commit all the cached data to WasmMemory.\n   * This function can only be called once.\n   * No further store function should be called.\n   *\n   * @param nbytes Number of bytes to be stored.\n   */\n  commitToWasmMemory(nbytes: number = this.stackTop): void {\n    // commit all pointer values.\n    while (this.addressToSetTargetValue.length != 0) {\n      const [targetOffset, valueOffset] = this.addressToSetTargetValue.pop() as [\n        number,\n        number\n      ];\n      this.storePtr(targetOffset, this.ptrFromOffset(valueOffset));\n    }\n    this.memory.storeRawBytes(this.basePtr, this.viewU8.slice(0, nbytes));\n  }\n\n  /**\n   * Allocate space by number of bytes\n   * @param nbytes Number of bytes.\n   * @note This function always allocate space that aligns to 64bit.\n   */\n  allocRawBytes(nbytes: number): PtrOffset {\n    // always aligns to 64bit\n    nbytes = ((nbytes + 7) >> 3) << 3;\n\n    if (this.stackTop + nbytes > this.buffer.byteLength) {\n      const newSize = Math.max(\n        this.buffer.byteLength * 2,\n        this.stackTop + nbytes\n      );\n      const oldU8 = this.viewU8;\n      this.buffer = new ArrayBuffer(newSize);\n      this.updateViews();\n      this.viewU8.set(oldU8);\n      if (this.basePtr != 0) {\n        this.cFreeSpace(this.basePtr);\n      }\n      this.basePtr = this.cAllocSpace(newSize);\n    }\n    const retOffset = this.stackTop;\n    this.stackTop += nbytes;\n    return retOffset;\n  }\n\n  /**\n   * Allocate space for pointers.\n   * @param count Number of pointers.\n   * @returns The allocated pointer array.\n   */\n  allocPtrArray(count: number): PtrOffset {\n    return this.allocRawBytes(this.memory.sizeofPtr() * count);\n  }\n\n  /**\n   * Get the real pointer from offset values.\n   * Note that the returned value becomes obsolete if alloc is called on the stack.\n   * @param offset The allocated offset.\n   */\n  ptrFromOffset(offset: PtrOffset): Pointer {\n    return this.basePtr + offset;\n  }\n\n  // Store APIs\n  storePtr(offset: PtrOffset, value: Pointer): void {\n    if (this.memory.wasm32) {\n      this.storeU32(offset, value);\n    } else {\n      this.storeI64(offset, value);\n    }\n  }\n\n  storeUSize(offset: PtrOffset, value: Pointer): void {\n    if (this.memory.wasm32) {\n      this.storeU32(offset, value);\n    } else {\n      this.storeI64(offset, value);\n    }\n  }\n\n  storeI32(offset: PtrOffset, value: number): void {\n    this.viewI32[offset >> 2] = value;\n  }\n\n  storeU32(offset: PtrOffset, value: number): void {\n    this.viewU32[offset >> 2] = value;\n  }\n\n  storeI64(offset: PtrOffset, value: number): void {\n    // For now, just store as 32bit\n    // NOTE: wasm always uses little endian.\n    const low = value & 0xffffffff;\n    const base = offset >> 2;\n    this.viewI32[base] = low;\n    this.viewI32[base + 1] = 0;\n  }\n\n  storeF64(offset: PtrOffset, value: number): void {\n    this.viewF64[offset >> 3] = value;\n  }\n\n  storeRawBytes(offset: PtrOffset, bytes: Uint8Array): void {\n    this.viewU8.set(bytes, offset);\n  }\n\n  /**\n   * Allocate then set C-String pointer to the offset.\n   * This function will call into allocBytes to allocate necessary data.\n   * The address won't be set immediately(because the possible change of basePtr)\n   * and will be filled when we commit the data.\n   *\n   * @param offset The offset to set ot data pointer.\n   * @param data The string content.\n   */\n  allocThenSetArgString(offset: PtrOffset, data: string): void {\n    const strOffset = this.allocRawBytes(data.length + 1);\n    this.storeRawBytes(strOffset, StringToUint8Array(data));\n    this.addressToSetTargetValue.push([offset, strOffset]);\n  }\n  /**\n   * Allocate then set the argument location with a TVMByteArray.\n   * Allocate new temporary space for bytes.\n   *\n   * @param offset The offset to set ot data pointer.\n   * @param data The string content.\n   */\n  allocThenSetArgBytes(offset: PtrOffset, data: Uint8Array): void {\n    // Note: size of size_t equals sizeof ptr.\n    const headerOffset = this.allocRawBytes(this.memory.sizeofPtr() * 2);\n    const dataOffset = this.allocRawBytes(data.length);\n    this.storeRawBytes(dataOffset, data);\n    this.storeUSize(headerOffset + this.memory.sizeofPtr(), data.length);\n\n    this.addressToSetTargetValue.push([offset, headerOffset]);\n    this.addressToSetTargetValue.push([headerOffset, dataOffset]);\n  }\n\n  /**\n   * Update internal cache views.\n   */\n  private updateViews(): void {\n    this.viewU8 = new Uint8Array(this.buffer);\n    this.viewI32 = new Int32Array(this.buffer);\n    this.viewU32 = new Uint32Array(this.buffer);\n    this.viewF64 = new Float64Array(this.buffer);\n  }\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { Pointer } from \"./ctypes\";\nimport { Memory } from \"./memory\";\nimport { assert } from \"./support\";\nimport { Disposable } from \"./types\";\n\n\n\n/** A pointer to points to the raw address space. */\nexport type GPUPointer = number;\n\nexport interface GPUDeviceDetectOutput {\n  adapter: GPUAdapter;\n  adapterInfo: GPUAdapterInfo;\n  device: GPUDevice;\n}\n\n/**\n * DetectGPU device in the environment.\n */\nexport async function detectGPUDevice(): Promise<GPUDeviceDetectOutput | undefined> {\n  if (typeof navigator !== \"undefined\" && navigator.gpu !== undefined) {\n    const adapter = await navigator.gpu.requestAdapter({ \"powerPreference\": \"high-performance\" });\n    if (adapter == null) {\n      throw Error(\"Cannot find adapter that matches the request\");\n    }\n    const computeMB = (value: number) => {\n      return Math.ceil(value / (1 << 20)) + \"MB\";\n    }\n\n    // more detailed error message\n    const requiedMaxBufferSize = 1 << 30;\n    if (requiedMaxBufferSize > adapter.limits.maxBufferSize) {\n      throw Error(\n        `Cannot initialize runtime because of requested maxBufferSize ` +\n        `exceeds limit. requested=${computeMB(requiedMaxBufferSize)}, ` +\n        `limit=${computeMB(adapter.limits.maxBufferSize)}. ` +\n        `This error may be caused by an older version of the browser (e.g. Chrome 112). ` +\n        `You can try to upgrade your browser to Chrome 113 or later.`\n      );\n    }\n\n    const requiredMaxStorageBufferBindingSize = 1 << 30;\n    if (requiredMaxStorageBufferBindingSize > adapter.limits.maxStorageBufferBindingSize) {\n      throw Error(\n        `Cannot initialize runtime because of requested maxStorageBufferBindingSize ` +\n        `exceeds limit. requested=${computeMB(requiredMaxStorageBufferBindingSize)}, ` +\n        `limit=${computeMB(adapter.limits.maxStorageBufferBindingSize)}. `\n      );\n    }\n\n    const requiredMaxComputeWorkgroupStorageSize = 32 << 10;\n    if (requiredMaxComputeWorkgroupStorageSize > adapter.limits.maxComputeWorkgroupStorageSize) {\n      throw Error(\n        `Cannot initialize runtime because of requested maxComputeWorkgroupStorageSize ` +\n        `exceeds limit. requested=${requiredMaxComputeWorkgroupStorageSize}, ` +\n        `limit=${adapter.limits.maxComputeWorkgroupStorageSize}. `\n      );\n    }\n\n    const adapterInfo = await adapter.requestAdapterInfo();\n    const device = await adapter.requestDevice({\n      requiredLimits: {\n        maxBufferSize: requiedMaxBufferSize,\n        maxStorageBufferBindingSize: requiredMaxStorageBufferBindingSize,\n        maxComputeWorkgroupStorageSize: requiredMaxComputeWorkgroupStorageSize,\n      }\n    });\n    return {\n      adapter: adapter,\n      adapterInfo: adapterInfo,\n      device: device\n    };\n  } else {\n    return undefined;\n  }\n}\n\nconst canvasRenderWGSL = `\n@group(0) @binding(0) var my_sampler : sampler;\n@group(0) @binding(1) var my_texture : texture_2d<f32>;\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) uv : vec2<f32>,\n}\n\n@vertex\nfn vertex_main(@builtin(vertex_index) vidx : u32) -> VertexOutput {\n  const pos = array(\n    vec2( 1.0,  1.0),\n    vec2( 1.0, -1.0),\n    vec2(-1.0, -1.0),\n    vec2( 1.0,  1.0),\n    vec2(-1.0, -1.0),\n    vec2(-1.0,  1.0),\n  );\n\n  const uv = array(\n    vec2(1.0, 0.0),\n    vec2(1.0, 1.0),\n    vec2(0.0, 1.0),\n    vec2(1.0, 0.0),\n    vec2(0.0, 1.0),\n    vec2(0.0, 0.0),\n  );\n\n  var output : VertexOutput;\n  output.position = vec4(pos[vidx], 0.0, 1.0);\n  output.uv = uv[vidx];\n  return output;\n}\n\n@fragment\nfn fragment_main(@location(0) uv : vec2<f32>) -> @location(0) vec4<f32> {\n  return textureSample(my_texture, my_sampler, uv);\n}\n\n@fragment\nfn fragment_clear(@location(0) uv : vec2<f32>) -> @location(0) vec4<f32> {\n  return vec4(1.0, 1.0, 1.0, 1.0);\n}\n`\nclass CanvaRenderManager implements Disposable {\n  private device: GPUDevice;\n  private canvasContext: GPUCanvasContext;\n  private stagingTexture: GPUTexture;\n  private renderSampler: GPUSampler;\n  private renderPipeline: GPURenderPipeline;\n  private clearPipeline: GPURenderPipeline;\n  private canvasTextureFormat: GPUTextureFormat;\n\n  constructor(device: GPUDevice, canvas: HTMLCanvasElement) {\n    this.device = device;\n    const ctx = canvas.getContext(\"webgpu\");\n    if (ctx == null) {\n      throw Error(\"Cannot bind WebGPU context\");\n    }\n    // @ts-ignore\n    this.canvasContext = ctx;\n    this.canvasTextureFormat = navigator.gpu.getPreferredCanvasFormat();\n    this.canvasContext.configure({\n      device: this.device,\n      format: this.canvasTextureFormat,\n      alphaMode: \"opaque\",\n    });\n\n    this.renderPipeline = device.createRenderPipeline({\n      layout: \"auto\",\n      vertex: {\n        module: device.createShaderModule({\n          code: canvasRenderWGSL,\n        }),\n        entryPoint: \"vertex_main\",\n      },\n      fragment: {\n        module: device.createShaderModule({\n          code: canvasRenderWGSL,\n        }),\n        entryPoint: \"fragment_main\",\n        targets: [{\n          format: this.canvasTextureFormat,\n        }],\n      },\n      primitive: {\n        topology: \"triangle-list\",\n      },\n    });\n\n    this.clearPipeline = device.createRenderPipeline({\n      layout: \"auto\",\n      vertex: {\n        module: device.createShaderModule({\n          code: canvasRenderWGSL,\n        }),\n        entryPoint: \"vertex_main\",\n      },\n      fragment: {\n        module: device.createShaderModule({\n          code: canvasRenderWGSL,\n        }),\n        entryPoint: \"fragment_clear\",\n        targets: [{\n          format: this.canvasTextureFormat,\n        }],\n      },\n      primitive: {\n        topology: \"triangle-list\",\n      },\n    });\n\n    this.renderSampler = device.createSampler({\n      magFilter: \"linear\",\n      minFilter: \"linear\",\n    });\n    // staging texture always be in RGBA\n    this.stagingTexture = device.createTexture({\n      size: [canvas.height, canvas.width, 1],\n      format: \"rgba8unorm\",\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n  }\n\n  clear() {\n    const commandEncoder = this.device.createCommandEncoder();\n    const passEncoder = commandEncoder.beginRenderPass({\n      //@ts-ignore\n      colorAttachments: [\n        {\n          view: this.canvasContext.getCurrentTexture().createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: \"clear\",\n          storeOp: \"store\",\n        },\n      ],\n    });\n    passEncoder.setPipeline(this.clearPipeline);\n    const renderBindingGroup = this.device.createBindGroup({\n      layout: this.renderPipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: this.renderSampler },\n        { binding: 1, resource: this.stagingTexture.createView() },\n      ],\n    });\n    passEncoder.setBindGroup(0, renderBindingGroup);\n    passEncoder.draw(6, 1, 0, 0);\n    passEncoder.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n  }\n\n  draw(buffer: GPUBuffer, height: number, width: number) {\n    // resize the staging texture\n    if (height != this.stagingTexture.height || width != this.stagingTexture.width) {\n      this.stagingTexture.destroy();\n      this.stagingTexture = this.device.createTexture({\n        size: [height, width, 1],\n        format: \"rgba8unorm\",\n        usage:\n          GPUTextureUsage.TEXTURE_BINDING |\n          GPUTextureUsage.COPY_DST |\n          GPUTextureUsage.RENDER_ATTACHMENT,\n      });\n    }\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyBufferToTexture({\n      buffer: buffer,\n      offset: 0,\n      bytesPerRow: this.stagingTexture.width * 4\n    }, {\n      texture: this.stagingTexture\n    }, {\n      width: this.stagingTexture.width,\n      height: this.stagingTexture.height\n    });\n\n    const passEncoder = commandEncoder.beginRenderPass({\n      //@ts-ignore\n      colorAttachments: [\n        {\n          view: this.canvasContext.getCurrentTexture().createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: \"clear\",\n          storeOp: \"store\",\n        },\n      ],\n    });\n    passEncoder.setPipeline(this.renderPipeline);\n    const renderBindingGroup = this.device.createBindGroup({\n      layout: this.renderPipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: this.renderSampler },\n        { binding: 1, resource: this.stagingTexture.createView() },\n      ],\n    });\n    passEncoder.setBindGroup(0, renderBindingGroup);\n    passEncoder.draw(6, 1, 0, 0);\n    passEncoder.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n  }\n\n  dispose(): void {\n    this.stagingTexture.destroy();\n  }\n}\n\n/**\n * Function info from the API\n */\nexport interface FunctionInfo {\n  name: string;\n  arg_types: Array<string>;\n  launch_param_tags: Array<string>;\n}\n\n/**\n * WebGPU context\n * Manages all the webgpu resources here.\n */\nexport class WebGPUContext {\n  device: GPUDevice;\n  memory: Memory;\n  // internal data\n  private bufferTable: Array<GPUBuffer | undefined> = [undefined];\n  private bufferTableFreeId: Array<number> = [];\n  private podArgStagingBuffers: Array<GPUBuffer> = [];\n  private canvasRenderManager?: CanvaRenderManager = undefined;\n  // number of pod arg staging buffers\n  private maxNumPodArgsStagingBuffers: number = 2;\n  // flags for debugging\n  // stats of the runtime.\n  // peak allocation\n  private peakAllocatedBytes: number = 0;\n  // current allocation\n  private currAllocatedBytes: number = 0;\n  // all allocation(ignoring free)\n  private allAllocatedBytes: number = 0;\n  // shader submit counter\n  private shaderSubmitCounter: number = 0;\n  // limite number of shaders to be submitted, useful for debugging, default to -1\n  protected debugShaderSubmitLimit: number = -1;\n  // log and sync each step\n  protected debugLogFinish: boolean = false;\n\n  constructor(memory: Memory, device: GPUDevice) {\n    this.memory = memory;\n    this.device = device;\n  }\n\n  /**\n   * Dispose context.\n   */\n  dispose() {\n    this.canvasRenderManager?.dispose();\n    this.bufferTableFreeId = [];\n    while (this.bufferTable.length != 0) {\n      this.bufferTable.pop()?.destroy();\n    }\n    while (this.podArgStagingBuffers.length != 0) {\n      this.podArgStagingBuffers.pop()?.destroy();\n    }\n    this.device.destroy();\n  }\n\n  /**\n   * Wait for all pending GPU tasks to complete\n   */\n  async sync(): Promise<void> {\n    await this.device.queue.onSubmittedWorkDone();\n  }\n\n  /**\n   * Obtain the runtime information in readable format.\n   */\n  runtimeStatsText(): string {\n    let info = \"peak-memory=\" + Math.ceil(this.peakAllocatedBytes / (1 << 20)) + \" MB\";\n    info += \", all-memory=\" + Math.ceil(this.allAllocatedBytes / (1 << 20)) + \" MB\";\n    info += \", shader-submissions=\" + this.shaderSubmitCounter;\n    return info;\n  }\n\n  /**\n   * Draw image from data in storage buffer.\n   * @param ptr The GPU ptr\n   * @param height The height of the image.\n   * @param width The width of the image.\n   */\n  drawImageFromBuffer(ptr: GPUPointer, height: number, width: number) {\n    if (this.canvasRenderManager == undefined) {\n      throw Error(\"Do not have a canvas context, call bindCanvas first\");\n    }\n    this.canvasRenderManager.draw(this.gpuBufferFromPtr(ptr), height, width);\n  }\n\n  /**\n   * Copy raw bytes into buffer ptr.\n   *\n   * @param rawBytes The raw bytes\n   * @param toPtr The target gpu buffer ptr\n   * @param toOffset The beginning offset\n   * @param nbytes Number of bytes\n   */\n  copyRawBytesToBuffer(\n    rawBytes: Uint8Array,\n    toPtr: GPUPointer,\n    toOffset: number,\n    nbytes: number\n  ): void {\n    // Perhaps it would be more useful to use a staging buffer?\n    this.device.queue.writeBuffer(\n      this.gpuBufferFromPtr(toPtr),\n      toOffset,\n      rawBytes,\n      0,\n      nbytes\n    );\n  }\n  /**\n   * Clear canvas\n   */\n  clearCanvas() {\n    this.canvasRenderManager?.clear();\n  }\n\n  /**\n   * Bind a canvas element to the runtime.\n   * @param canvas The HTML canvas/\n   */\n  bindCanvas(canvas: HTMLCanvasElement) {\n    this.canvasRenderManager = new CanvaRenderManager(this.device, canvas);\n  }\n\n  /**\n   * Create a PackedFunc that runs the given shader\n   * via createComputePipeline\n   *\n   * @param info The function information already parsed as a record.\n   * @param code The shader data(in WGSL)\n   * @returns The shader\n   */\n  createShader(finfo: FunctionInfo, code: string): Function {\n    return this.createShadeInternal(finfo, code, false) as Function;\n  }\n\n  /**\n   * Create a PackedFunc that runs the given shader asynchrously\n   * via createComputePipelineAsync\n   *\n   * @param info The function information already parsed as a record.\n   * @param code The shader data(in WGSL)\n   * @returns The shader\n   */\n  async createShaderAsync(finfo: FunctionInfo, code: string): Promise<Function> {\n    return await (this.createShadeInternal(finfo, code, true) as Promise<Function>);\n  }\n\n  /**\n   * Get the pod arg staging buffer\n   * \\param nbytes The minimum size.\n   * \\return The allocated buffer\n   */\n  private getPodArgsBuffer(nbytes: number): GPUBuffer {\n    let buffer: GPUBuffer | undefined = undefined;\n    if (this.podArgStagingBuffers.length >= this.maxNumPodArgsStagingBuffers) {\n      buffer = this.podArgStagingBuffers.shift();\n    }\n    // minimum of 16 bytes\n    let allocSize = 16;\n    if (buffer !== undefined) {\n      allocSize = buffer.size;\n      if (buffer.size < nbytes) {\n        buffer.destroy();\n        buffer = undefined;\n      }\n    }\n    while (allocSize < nbytes) {\n      allocSize *= 2;\n    }\n\n    if (buffer == undefined) {\n      // create uniform buffer\n      buffer = this.device.createBuffer({\n        size: allocSize,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n      });\n    }\n    assert(nbytes <= buffer.size);\n    return buffer;\n  }\n\n  /**\n   * Internal impl of createShader for both async and sync mode.\n   *\n   * @param info The function information already parsed as a record.\n   * @param code The shader data(in WGSL)\n   * @param asyncMode Whether use async mode.\n   * @returns The shader function or promise of shader func.\n   */\n  private createShadeInternal(\n    finfo: FunctionInfo,\n    code: string,\n    asyncMode: boolean\n  ): Function | Promise<Function> {\n    const dispatchToDim: Array<number> = [];\n    let paramWriteAccess: Array<number> = [];\n\n    for (let i = 0; i < finfo.launch_param_tags.length; ++i) {\n      const tag: string = finfo.launch_param_tags[i];\n      if (tag.startsWith(\"blockIdx.\")) {\n        const target: number = tag.charCodeAt(tag.length - 1) - (\"x\".charCodeAt(0));\n        assert(target >= 0 && target < 3);\n        dispatchToDim.push(target);\n      } else if (tag.startsWith(\"threadIdx.\")) {\n        const target: number = tag.charCodeAt(tag.length - 1) - (\"x\".charCodeAt(0));\n        assert(target >= 0 && target < 3);\n        dispatchToDim.push(target + 3);\n      } else if (tag.startsWith(\"paramWriteAccess:\")) {\n        paramWriteAccess = JSON.parse(tag.substring(17));\n      } else {\n        throw new Error(\"Cannot handle thread_axis \" + tag);\n      }\n    }\n\n\n    const layoutEntries: Array<GPUBindGroupLayoutEntry> = [];\n    const bufferArgIndices: Array<number> = [];\n    const podArgIndices: Array<number> = [];\n\n    for (let i = 0; i < finfo.arg_types.length; ++i) {\n      const dtype = finfo.arg_types[i];\n      if (dtype == \"handle\") {\n        layoutEntries.push({\n          binding: bufferArgIndices.length,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: {\n            type: paramWriteAccess[bufferArgIndices.length] ? \"storage\" : \"read-only-storage\"\n          }\n        });\n        bufferArgIndices.push(i);\n      } else if (dtype.startsWith(\"int\") || dtype.startsWith(\"uint\") || dtype.startsWith(\"float\")) {\n        podArgIndices.push(i);\n      } else {\n        throw new Error(\"Cannot handle argument type \" + dtype + \" in WebGPU shader\");\n      }\n    }\n\n    assert(paramWriteAccess.length == bufferArgIndices.length);\n    // POD arguments are pass in the end\n    layoutEntries.push({\n      binding: bufferArgIndices.length,\n      visibility: GPUShaderStage.COMPUTE,\n      buffer: {\n        type: \"uniform\"\n      }\n    });\n\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: layoutEntries\n    });\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout]\n    });\n\n    // Function to create the pipeline.\n    const createShaderFunc = (pipeline: GPUComputePipeline): Function => {\n      const submitShader = (...args: Array<GPUPointer | number>): void => {\n        if (this.debugShaderSubmitLimit != -1 &&\n          this.shaderSubmitCounter >= this.debugShaderSubmitLimit) {\n          this.shaderSubmitCounter += 1;\n          return;\n        }\n\n        const commandEncoder = this.device.createCommandEncoder();\n        const compute = commandEncoder.beginComputePass();\n        compute.setPipeline(pipeline);\n        const bindGroupEntries: Array<GPUBindGroupEntry> = [];\n        const numBufferOrPodArgs = bufferArgIndices.length + podArgIndices.length;\n\n        assert(args.length == numBufferOrPodArgs + dispatchToDim.length);\n\n        const workDim: Array<number> = [1, 1, 1, 1, 1, 1];\n        for (let i = 0; i < dispatchToDim.length; ++i) {\n          workDim[dispatchToDim[i]] = args[numBufferOrPodArgs + i];\n        }\n\n        // get around 65535 restriction of blockIdx.x\n        if (workDim[2] != 1) {\n          throw Error(\"WebGPU: blockIdx.z is reserved for internal use\");\n        }\n        const packDimX = workDim[0];\n        // spread thinsg out into blockIdx.z\n        if (workDim[0] >= (1 << 16)) {\n          let wl_x = workDim[0];\n          let wl_z = workDim[2];\n\n          while (wl_x >= (1 << 16)) {\n            if (wl_x % 2 == 0) {\n              wl_x = wl_x / 2;\n            } else {\n              // pad up\n              wl_x = (wl_x + 1) / 2;\n            }\n            wl_z *= 2;\n          }\n          workDim[0] = wl_x;\n          workDim[2] = wl_z;\n          assert(wl_x * wl_z >= packDimX);\n        }\n\n        for (let i = 0; i < bufferArgIndices.length; ++i) {\n          bindGroupEntries.push({\n            binding: i,\n            resource: {\n              buffer: this.gpuBufferFromPtr(args[bufferArgIndices[i]])\n            }\n          });\n        }\n\n        // push pod buffer\n        const sizeOfI32 = 4;\n        const podArgBuffer = this.getPodArgsBuffer((podArgIndices.length + 1) * sizeOfI32);\n        const i32View = new Int32Array(podArgIndices.length + 1);\n        const u32View = new Uint32Array(i32View.buffer);\n        const f32View = new Float32Array(i32View.buffer);\n\n        for (let i = 0; i < podArgIndices.length; ++i) {\n          const value = args[podArgIndices[i]];\n          const dtype = finfo.arg_types[podArgIndices[i]];\n          if (dtype.startsWith(\"int\")) {\n            i32View[i] = value;\n          } else if (dtype.startsWith(\"uint\")) {\n            u32View[i] = value;\n          } else if (dtype.startsWith(\"float\")) {\n            f32View[i] = value;\n          } else {\n            throw Error(\"Unknown pod dtype \" + dtype);\n          }\n        }\n        // always pass in dim z launching grid size in\n        u32View[podArgIndices.length] = packDimX;\n        this.device.queue.writeBuffer(podArgBuffer, 0, i32View.buffer);\n\n        bindGroupEntries.push({\n          binding: bufferArgIndices.length,\n          resource: {\n            buffer: podArgBuffer,\n            size: i32View.buffer.byteLength\n          }\n        });\n\n        compute.setBindGroup(0, this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: bindGroupEntries\n        }));\n\n        compute.dispatchWorkgroups(workDim[0], workDim[1], workDim[2])\n        compute.end()\n        const command = commandEncoder.finish();\n        this.device.queue.submit([command]);\n\n        if (this.debugLogFinish) {\n          const currCounter = this.shaderSubmitCounter;\n          this.device.queue.onSubmittedWorkDone().then(() => {\n            // console.log(\"[\" + currCounter + \"][Debug] finish shader\" + finfo.name);\n          });\n        }\n        this.shaderSubmitCounter += 1;\n      };\n      return submitShader;\n    };\n\n    const shaderModule = this.device.createShaderModule({\n      code: code,\n      hints: {\n        main: {\n          layout: pipelineLayout\n        }\n      }\n    });\n\n    if (asyncMode) {\n      return this.device.createComputePipelineAsync({\n        layout: pipelineLayout,\n        compute: {\n          module: shaderModule,\n          entryPoint: finfo.name\n        }\n      }).then((pipeline: GPUComputePipeline) => {\n        return createShaderFunc(pipeline);\n      });\n    } else {\n      const pipeline = this.device.createComputePipeline({\n        layout: pipelineLayout,\n        compute: {\n          module: shaderModule,\n          entryPoint: finfo.name\n        }\n      });\n      return createShaderFunc(pipeline);\n    }\n  }\n\n  /**\n   * Get the device API according to its name\n   * @param The name of the API.\n   * @returns The corresponding device api.\n   */\n  getDeviceAPI(name: string): Function {\n    if (name == \"deviceAllocDataSpace\") {\n      return (nbytes: number): GPUPointer => {\n        return this.deviceAllocDataSpace(nbytes);\n      };\n    } else if (name == \"deviceFreeDataSpace\") {\n      return (ptr: GPUPointer): void => {\n        return this.deviceFreeDataSpace(ptr);\n      };\n    } else if (name == \"deviceCopyToGPU\") {\n      return (\n        from: Pointer,\n        to: GPUPointer,\n        toOffset: number,\n        nbytes: number\n      ): void => {\n        this.deviceCopyToGPU(from, to, toOffset, nbytes);\n      };\n    } else if (name == \"deviceCopyFromGPU\") {\n      return (\n        from: GPUPointer,\n        fromOffset: number,\n        to: Pointer,\n        nbytes: number\n      ): void => {\n        this.deviceCopyFromGPU(from, fromOffset, to, nbytes);\n      };\n    } else if (name == \"deviceCopyWithinGPU\") {\n      return (\n        from: GPUPointer,\n        fromOffset: number,\n        to: Pointer,\n        toOffset: number,\n        nbytes: number\n      ): void => {\n        this.deviceCopyWithinGPU(from, fromOffset, to, toOffset, nbytes);\n      };\n    } else {\n      throw new Error(\"Unknown DeviceAPI function \" + name);\n    }\n  }\n\n  // DeviceAPI\n  private deviceAllocDataSpace(nbytes: number): GPUPointer {\n    // allocate 0 bytes buffer as 1 bytes buffer.\n    if (nbytes == 0) {\n      nbytes = 1;\n    }\n    const buffer = this.device.createBuffer({\n      size: nbytes,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    this.currAllocatedBytes += nbytes;\n    this.allAllocatedBytes += nbytes;\n    if (this.currAllocatedBytes > this.peakAllocatedBytes) {\n      this.peakAllocatedBytes = this.currAllocatedBytes;\n    }\n    const ptr = this.attachToBufferTable(buffer);\n    return ptr;\n  }\n\n  private deviceFreeDataSpace(ptr: GPUPointer): void {\n    const idx = ptr;\n    const buffer = this.bufferTable[idx];\n    this.bufferTable[idx] = undefined;\n    assert(buffer !== undefined);\n    this.bufferTableFreeId.push(idx);\n    this.currAllocatedBytes -= buffer.size;\n    buffer.destroy();\n  }\n\n  private deviceCopyToGPU(\n    from: Pointer,\n    to: GPUPointer,\n    toOffset: number,\n    nbytes: number\n  ): void {\n    // Perhaps it would be more useful to use a staging buffer?\n    const rawBytes = this.memory.loadRawBytes(from, nbytes);\n    this.device.queue.writeBuffer(\n      this.gpuBufferFromPtr(to),\n      toOffset,\n      rawBytes,\n      0,\n      nbytes\n    );\n  }\n\n  private deviceCopyFromGPU(\n    from: GPUPointer,\n    fromOffset: number,\n    to: Pointer,\n    nbytes: number\n  ): void {\n    // Perhaps it would be more useful to resuse a staging buffer?\n    const gpuTemp = this.device.createBuffer({\n      size: nbytes,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n\n    const copyEncoder = this.device.createCommandEncoder();\n    copyEncoder.copyBufferToBuffer(\n      this.gpuBufferFromPtr(from),\n      fromOffset,\n      gpuTemp,\n      0,\n      nbytes\n    );\n    const copyCommands = copyEncoder.finish();\n    this.device.queue.submit([copyCommands]);\n\n    gpuTemp.mapAsync(GPUMapMode.READ).then(() => {\n      const data = gpuTemp.getMappedRange();\n      this.memory.storeRawBytes(to, new Uint8Array(data));\n      gpuTemp.destroy();\n    });\n  }\n\n  private deviceCopyWithinGPU(\n    from: GPUPointer,\n    fromOffset: number,\n    to: Pointer,\n    toOffset: number,\n    nbytes: number\n  ): void {\n    const copyEncoder = this.device.createCommandEncoder();\n    copyEncoder.copyBufferToBuffer(\n      this.gpuBufferFromPtr(from),\n      fromOffset,\n      this.gpuBufferFromPtr(to),\n      toOffset,\n      nbytes\n    );\n    const copyCommands = copyEncoder.finish();\n    this.device.queue.submit([copyCommands]);\n  }\n\n  private gpuBufferFromPtr(ptr: GPUPointer): GPUBuffer {\n    const buffer = this.bufferTable[ptr];\n    assert(buffer !== undefined);\n    return buffer;\n  }\n\n  private attachToBufferTable(buffer: GPUBuffer): GPUPointer {\n    if (this.bufferTableFreeId.length != 0) {\n      const idx = this.bufferTableFreeId.pop() as number;\n      this.bufferTable[idx] = buffer;\n      return idx;\n    } else {\n      const idx = this.bufferTable.length;\n      this.bufferTable.push(buffer);\n      return idx;\n    }\n  }\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * TVM JS Wasm Runtime library.\n */\nimport { ArgTypeCode, Pointer, PtrOffset, SizeOf } from \"./ctypes\";\nimport { Environment } from \"./environment\";\nimport { CachedCallStack, Memory } from \"./memory\";\nimport { StringToUint8Array, assert } from \"./support\";\nimport { Disposable } from \"./types\";\nimport { FunctionInfo, WebGPUContext } from \"./webgpu\";\n\nimport * as compact from \"./compact\";\nimport * as ctypes from \"./ctypes\";\n\n/**\n * Type for PackedFunc inthe TVMRuntime.\n */\nexport type PackedFunc = ((...args: any) => any) &\n  Disposable & { _tvmPackedCell: PackedFuncCell };\n\n/**\n * @internal\n * FFI Library wrapper, maintains most runtime states.\n */\nclass FFILibrary implements Disposable {\n  wasm32: boolean;\n  memory: Memory;\n  exports: Record<string, Function>;\n  webGPUContext?: WebGPUContext;\n  private wasmInstance: WebAssembly.Instance;\n  private recycledCallStacks: Array<CachedCallStack> = [];\n\n  constructor(\n    wasmInstance: WebAssembly.Instance,\n    imports: Record<string, any>\n  ) {\n    this.wasmInstance = wasmInstance;\n    this.memory = new Memory(this.detectWasmMemory(this.wasmInstance, imports));\n    assert(\n      this.wasmInstance.exports !== undefined,\n      \"Expect the library module contains exports\"\n    );\n    this.exports = this.wasmInstance.exports as Record<string, Function>;\n    this.wasm32 = this.memory.wasm32;\n    this.validateInstance();\n  }\n\n  dispose(): void {\n    while (this.recycledCallStacks.length != 0) {\n      (this.recycledCallStacks.pop() as Disposable).dispose();\n    }\n    this.webGPUContext?.dispose();\n  }\n\n  sizeofPtr(): number {\n    return this.memory.sizeofPtr();\n  }\n\n  checkCall(code: number): void {\n    if (code != 0) {\n      const msgPtr = (this.exports\n        .TVMGetLastError as ctypes.FTVMGetLastError)();\n      throw new Error(\"TVMError: \" + this.memory.loadCString(msgPtr));\n    }\n  }\n\n  getOrAllocCallStack(): CachedCallStack {\n    if (this.recycledCallStacks.length != 0) {\n      return this.recycledCallStacks.pop() as CachedCallStack;\n    }\n    return new CachedCallStack(\n      this.memory,\n      this.exports.TVMWasmAllocSpace as ctypes.FTVMWasmAllocSpace,\n      this.exports.TVMWasmFreeSpace as ctypes.FTVMWasmFreeSpace\n    );\n  }\n\n  recycleCallStack(callstack: CachedCallStack): void {\n    callstack.reset();\n    this.recycledCallStacks.push(callstack);\n  }\n\n  private validateInstance(): void {\n    this.checkExports([\"TVMWasmAllocSpace\", \"TVMWasmFreeSpace\", \"TVMFuncFree\"]);\n  }\n\n  private checkExports(funcNames: Array<string>): void {\n    const missList = [];\n    for (const name of funcNames) {\n      const f = this.exports[name];\n      if (!(f instanceof Function)) {\n        missList.push(name);\n      }\n    }\n    if (missList.length != 0) {\n      throw new Error(\"Cannot find \" + missList + \" in exports\");\n    }\n  }\n\n  private detectWasmMemory(\n    instance: WebAssembly.Instance,\n    imports: Record<string, any>\n  ): WebAssembly.Memory {\n    if (instance.exports.memory instanceof WebAssembly.Memory) {\n      return instance.exports.memory;\n    }\n    if (imports.env && imports.env.memory instanceof WebAssembly.Memory) {\n      return imports.env.memory;\n    }\n\n    throw new Error(\n      \"Cannt detect wasm memory from imports \" +\n      imports +\n      \" or exports\" +\n      instance.exports\n    );\n  }\n}\n\n/**\n * @internal\n * Manages extra runtime context for the runtime.\n */\nclass RuntimeContext implements Disposable {\n  arrayGetItem: PackedFunc;\n  arrayGetSize: PackedFunc;\n  arrayMake: PackedFunc;\n  getSysLib: PackedFunc;\n  arrayCacheGet: PackedFunc;\n  arrayCacheUpdate: PackedFunc;\n  arrayCacheRemove: PackedFunc;\n  arrayCacheClear: PackedFunc;\n  arrayDecodeStorage: PackedFunc;\n  paramModuleFromCache: PackedFunc;\n  makeShapeTuple: PackedFunc;\n  ndarrayCreateView: PackedFunc;\n  sampleTopPFromLogits: PackedFunc;\n\n  private autoDisposeScope: Array<Array<Disposable | undefined>> = [];\n\n  constructor(getGlobalFunc: (name: string) => PackedFunc) {\n    this.arrayGetItem = getGlobalFunc(\"runtime.ArrayGetItem\");\n    this.arrayGetSize = getGlobalFunc(\"runtime.ArraySize\");\n    this.arrayMake = getGlobalFunc(\"runtime.Array\");\n    this.getSysLib = getGlobalFunc(\"runtime.SystemLib\");\n    this.arrayCacheGet = getGlobalFunc(\"vm.builtin.ndarray_cache.get\");\n    this.arrayCacheRemove = getGlobalFunc(\"vm.builtin.ndarray_cache.remove\");\n    this.arrayCacheUpdate = getGlobalFunc(\"vm.builtin.ndarray_cache.update\");\n    this.arrayCacheClear = getGlobalFunc(\"vm.builtin.ndarray_cache.clear\");\n    this.arrayDecodeStorage = getGlobalFunc(\"tvmjs.array.decode_storage\");\n    this.paramModuleFromCache = getGlobalFunc(\"vm.builtin.param_module_from_cache\");\n    this.makeShapeTuple = getGlobalFunc(\"runtime.ShapeTuple\");\n    this.ndarrayCreateView = getGlobalFunc(\"runtime.TVMArrayCreateView\");\n    this.sampleTopPFromLogits = getGlobalFunc(\"vm.builtin.sample_top_p_from_logits\");\n  }\n\n  dispose(): void {\n    // call array cache clear to clear all cached items\n    this.arrayCacheClear.dispose();\n    this.arrayGetItem.dispose();\n    this.arrayGetSize.dispose();\n    this.arrayMake.dispose();\n    this.arrayCacheGet.dispose();\n    this.arrayCacheRemove.dispose();\n    this.arrayCacheUpdate.dispose();\n    this.arrayCacheClear.dispose();\n    this.arrayDecodeStorage.dispose();\n    this.paramModuleFromCache.dispose();\n    this.makeShapeTuple.dispose();\n    this.ndarrayCreateView.dispose();\n    this.sampleTopPFromLogits.dispose();\n  }\n\n  beginScope(): void {\n    this.autoDisposeScope.push([]);\n  }\n\n  endScope(): void {\n    if (this.autoDisposeScope.length == 0) {\n      throw Error(\"tvm.endScope called when the stack is empty.\");\n    }\n    // automatically dispose all the tracked values in the current scope.\n    const currScope = this.autoDisposeScope.pop() as Array<Disposable | undefined>;\n    for (let i = 0; i < currScope.length; ++i) {\n      const val = currScope[i];\n      if (val !== undefined) {\n        val.dispose();\n      }\n    }\n  }\n\n  /**\n   * Track object for dispose in current scope.\n   *\n   * @param obj The object to be tracked.\n   * @returns the same object.\n   * @note This function only needs to be called for raw system C API values.\n   *       The return value of PackedFunc will be automatically tracked.\n   */\n  attachToCurrentScope<T extends Disposable>(obj: T): T {\n    if (this.autoDisposeScope.length == 0) {\n      throw Error(\"Must call beginScope to use functions that returns TVM objects\");\n    }\n    const currScope = this.autoDisposeScope[this.autoDisposeScope.length - 1];\n    currScope.push(obj);\n    return obj;\n  }\n\n  moveToParentScope<T extends Disposable>(obj: T): T {\n    this.detachFromCurrentScope(obj);\n    if (this.autoDisposeScope.length < 2) {\n      throw Error(\"moveToParentScope: Parent scope do not exist\");\n    }\n    const parentScope = this.autoDisposeScope[this.autoDisposeScope.length - 2];\n    parentScope.push(obj);\n    return obj;\n  }\n\n  detachFromCurrentScope<T extends Disposable>(obj: T): T {\n    const currScope = this.autoDisposeScope[this.autoDisposeScope.length - 1];\n    let occurance = 0;\n    for (let i = 0; i < currScope.length; ++i) {\n      if (currScope[i] === obj) {\n        occurance += 1;\n        currScope[i] = undefined;\n      }\n    }\n    if (occurance == 0) {\n      throw Error(\"Cannot find obj in the current auto conversion pool\");\n    }\n    if (occurance > 1) {\n      throw Error(\"Value attached to scope multiple times\");\n    }\n    return obj;\n  }\n}\n\n/**\n * A typed scalar constant used to represent a typed number\n * argument to PackedFunc calls.\n */\nexport class Scalar {\n  /** The value. */\n  value: number;\n  /** The data type of the scalar. */\n  dtype: string;\n\n  constructor(value: number, dtype: string) {\n    this.value = value;\n    this.dtype = dtype;\n  }\n}\n\n/**\n * Cell holds the PackedFunc object.\n */\nclass PackedFuncCell implements Disposable {\n  private handle: Pointer;\n  private lib: FFILibrary;\n\n  constructor(handle: Pointer, lib: FFILibrary) {\n    this.handle = handle;\n    this.lib = lib;\n  }\n\n  dispose(): void {\n    if (this.handle != 0) {\n      this.lib.checkCall(\n        (this.lib.exports.TVMFuncFree as ctypes.FTVMFuncFree)(this.handle)\n      );\n      this.handle = 0;\n    }\n  }\n\n  getHandle(requireNotNull: boolean = true): Pointer {\n    if (requireNotNull && this.handle == 0) {\n      throw Error(\"PackedFunc has already been disposed\");\n    }\n    return this.handle;\n  }\n}\n\nconst DeviceEnumToStr: Record<number, string> = {\n  1: \"cpu\",\n  2: \"cuda\",\n  4: \"opencl\",\n  8: \"metal\",\n  15: \"webgpu\"\n};\n\nconst DeviceStrToEnum: Record<string, number> = {\n  cpu: 1,\n  cuda: 2,\n  cl: 4,\n  opencl: 4,\n  vulkan: 7,\n  metal: 8,\n  webgpu: 15\n};\n\n/**\n * Represent a runtime context where a NDArray can reside.\n */\nexport class DLDevice {\n  /** The device type code of the device. */\n  deviceType: number;\n  /** The device index. */\n  deviceId: number;\n\n  private lib: FFILibrary;\n\n  constructor(deviceType: number | string, deviceId: number, lib: FFILibrary) {\n    const tp = typeof deviceType;\n    if (tp == \"string\") {\n      this.deviceType = DeviceStrToEnum[deviceType];\n      if (this.deviceType == undefined) {\n        throw new Error(\"Cannot recogonize deviceType \" + deviceType);\n      }\n    } else if (tp == \"number\") {\n      this.deviceType = deviceType as number;\n    } else {\n      throw new Error(\"Cannot take type \" + tp + \" as deviceType\");\n    }\n    this.deviceId = deviceId;\n    this.lib = lib;\n  }\n\n  /**\n   * Synchronize the device\n   */\n  async sync(): Promise<void> {\n    if (this.deviceType == DeviceStrToEnum.webgpu) {\n      assert(this.lib.webGPUContext !== undefined);\n      await this.lib.webGPUContext.sync();\n    }\n  }\n\n  toString(): string {\n    return (\n      DeviceEnumToStr[this.deviceType] + \"(\" + this.deviceId.toString() + \")\"\n    );\n  }\n}\n/**\n * The data type code in DLDataType\n */\nexport const enum DLDataTypeCode {\n  Int = 0,\n  UInt = 1,\n  Float = 2,\n  OpaqueHandle = 3\n}\n\nconst DLDataTypeCodeToStr: Record<number, string> = {\n  0: \"int\",\n  1: \"uint\",\n  2: \"float\",\n  3: \"handle\",\n};\n\n/**\n * Runtime data type of NDArray.\n */\nexport class DLDataType {\n  /** The type code */\n  code: number;\n  /** Number of bits in the data type. */\n  bits: number;\n  /** Number of vector lanes. */\n  lanes: number;\n\n  constructor(code: number, bits: number, lanes: number) {\n    this.code = code;\n    this.bits = bits;\n    this.lanes = lanes;\n  }\n\n  toString(): string {\n    const ret = DLDataTypeCodeToStr[this.code] + this.bits.toString();\n    if (this.lanes != 1) {\n      return ret + \"x\" + this.lanes.toString();\n    } else {\n      return ret;\n    }\n  }\n\n  numStorageBytes(): number {\n    return (this.bits * this.lanes + 7) >> 3;\n  }\n}\n\n/**\n * n-dimnesional array.\n */\nexport class NDArray implements Disposable {\n  /** Internal array handle. */\n  private handle: Pointer;\n  /** Number of dimensions. */\n  ndim: number;\n  /** Data type of the array. */\n  dtype: string;\n  /** Shape of the array. */\n  shape: Array<number>;\n  /** Device of the array. */\n  device: DLDevice;\n  /** Whether it is a temporary view that can become invalid after the call. */\n  isView: boolean;\n  private byteOffset: number;\n  private dltensor: Pointer;\n  private dataPtr: Pointer;\n  private lib: FFILibrary;\n  private ctx: RuntimeContext;\n  private dlDataType: DLDataType;\n\n  constructor(handle: Pointer, isView: boolean, lib: FFILibrary, ctx: RuntimeContext) {\n    this.handle = handle;\n    this.isView = isView;\n    this.lib = lib;\n    this.ctx = ctx;\n\n    if (this.isView) {\n      this.dltensor = handle;\n    } else {\n      this.dltensor = this.getDLTensorFromArrayHandle(this.handle);\n    }\n    // constant offsets.\n    const arrayOffsetData = 0;\n    const arrayOffsetContext = arrayOffsetData + this.lib.sizeofPtr();\n    const arrayOffsetDevType = arrayOffsetContext;\n    const arrayOffsetDevId = arrayOffsetContext + SizeOf.I32;\n    const arrayOffsetNdim = arrayOffsetContext + SizeOf.DLDevice;\n    const arrayOffsetDtype = arrayOffsetNdim + SizeOf.I32;\n    const arrayOffsetDtypeCode = arrayOffsetDtype;\n    const arrayOffsetDtypeBits = arrayOffsetDtype + SizeOf.U8;\n    const arrayOffsetDtypeLanes = arrayOffsetDtypeBits + SizeOf.U8;\n    const arrayOffsetShape = arrayOffsetDtype + SizeOf.DLDataType;\n    const arrayOffsetStrides = arrayOffsetShape + this.lib.sizeofPtr();\n    const arrayOffsetByteOffset = arrayOffsetStrides + this.lib.sizeofPtr();\n    // dataPtr\n    this.dataPtr = lib.memory.loadPointer(this.dltensor);\n    // ndim\n    this.ndim = lib.memory.loadI32(this.dltensor + arrayOffsetNdim);\n    // shape\n    const cshapePtr = lib.memory.loadPointer(this.dltensor + arrayOffsetShape);\n    this.shape = [];\n    for (let i = 0; i < this.ndim; ++i) {\n      this.shape.push(lib.memory.loadI64(cshapePtr + i * SizeOf.I64));\n    }\n    // dtype\n    const code = lib.memory.loadU8(this.dltensor + arrayOffsetDtypeCode);\n    const bits = lib.memory.loadU8(this.dltensor + arrayOffsetDtypeBits);\n    const lanes = lib.memory.loadU16(this.dltensor + arrayOffsetDtypeLanes);\n    this.dlDataType = new DLDataType(code, bits, lanes);\n    this.dtype = this.dlDataType.toString();\n\n    // device\n    const deviceType = lib.memory.loadI32(this.dltensor + arrayOffsetDevType);\n    const deviceId = lib.memory.loadI32(this.dltensor + arrayOffsetDevId);\n    this.device = new DLDevice(deviceType, deviceId, lib);\n\n    // byte_offset\n    this.byteOffset = lib.memory.loadI64(this.dltensor + arrayOffsetByteOffset);\n  }\n\n  /**\n   * Create a view of the array.\n   * @param shape The shape of the view.\n   * @returns The new sliced ndarray.\n   */\n  view(shape: Array<number>): NDArray {\n    const shapeArray = shape.map((value) => new Scalar(value, \"int\"));\n    return this.ctx.ndarrayCreateView(this, this.ctx.makeShapeTuple(...shapeArray));\n  }\n\n  /**\n   * Get handle of ndarray, check it is not null.\n   *\n   * @param requireNotNull require handle is not null.\n   * @returns The handle.\n   */\n  getHandle(requireNotNull: boolean = true): Pointer {\n    if (requireNotNull && this.handle == 0) {\n      throw Error(\"NDArray has already been disposed\");\n    }\n    return this.handle;\n  }\n\n  /**\n   * Get dataPtr of NDarray\n   *\n   * @returns The handle.\n   */\n  getDataPtr(): Pointer {\n    if (this.handle == 0) {\n      throw Error(\"NDArray has already been disposed\");\n    }\n    return this.dataPtr;\n  }\n\n  dispose(): void {\n    if (this.handle != 0 && !this.isView) {\n      this.lib.checkCall(\n        (this.lib.exports.TVMArrayFree as ctypes.FTVMArrayFree)(this.handle)\n      );\n      this.handle = 0;\n    }\n  }\n  /**\n   * Copy data from another NDArray or javascript array.\n   * The number of elements must match.\n   *\n   * @param data The source data array.\n   * @returns this\n   */\n  copyFrom(data: NDArray | Array<number> | Float32Array): this {\n    if (data instanceof NDArray) {\n      this.lib.checkCall(\n        (this.lib.exports.TVMArrayCopyFromTo as ctypes.FTVMArrayCopyFromTo)(\n          data.getHandle(),\n          this.getHandle(),\n          0\n        )\n      );\n      return this;\n    } else {\n      const size = this.shape.reduce((a, b) => {\n        return a * b;\n      }, 1);\n      if (data.length != size) {\n        throw new Error(\n          \"data size and shape mismatch data.length\" +\n          data.length +\n          \" vs \" +\n          size\n        );\n      }\n      let buffer: ArrayBuffer;\n      if (this.dtype == \"float32\") {\n        buffer = Float32Array.from(data).buffer;\n      } else if (this.dtype == \"float64\") {\n        buffer = Float64Array.from(data).buffer;\n      } else if (this.dtype == \"int32\") {\n        buffer = Int32Array.from(data).buffer;\n      } else if (this.dtype == \"int8\") {\n        buffer = Int8Array.from(data).buffer;\n      } else if (this.dtype == \"uint8\") {\n        buffer = Uint8Array.from(data).buffer;\n      } else {\n        throw new Error(\"Unsupported data type \" + this.dtype);\n      }\n      return this.copyFromRawBytes(new Uint8Array(buffer));\n    }\n  }\n  /**\n   * Copy data from raw bytes.\n   * @param data Uint8Array of bytes.\n   * @returns this\n   */\n  copyFromRawBytes(data: Uint8Array): this {\n    // short cut for gpu copy\n    if (this.device.deviceType == DeviceStrToEnum.webgpu) {\n      this.lib.webGPUContext?.copyRawBytesToBuffer(data, this.getDataPtr(), 0, data.length);\n      return this;\n    }\n    // CPU copy\n    const size = this.shape.reduce((a, b) => {\n      return a * b;\n    }, 1);\n    const nbytes = this.dlDataType.numStorageBytes() * size;\n    if (nbytes != data.length) {\n      throw new Error(\"Expect the data's length equals nbytes=\" + nbytes);\n    }\n\n    const stack = this.lib.getOrAllocCallStack();\n\n    const tempOffset = stack.allocRawBytes(nbytes);\n    const tempPtr = stack.ptrFromOffset(tempOffset);\n    this.lib.memory.storeRawBytes(tempPtr, data);\n    this.lib.checkCall(\n      (this.lib.exports.TVMArrayCopyFromBytes as ctypes.FTVMArrayCopyFromBytes)(\n        this.getHandle(),\n        tempPtr,\n        nbytes\n      )\n    );\n\n    this.lib.recycleCallStack(stack);\n    return this;\n  }\n  /**\n   * Return a copied Uint8Array of the raw bytes in the NDArray.\n   * @returns The result array.\n   */\n  toRawBytes(): Uint8Array {\n    if (this.device.deviceType != DeviceStrToEnum.cpu) {\n      throw new Error(\"Can only sync copy CPU array, use cpu_arr.copyfrom(gpu_arr) then sync instead.\");\n    }\n    const size = this.shape.reduce((a, b) => {\n      return a * b;\n    }, 1);\n\n    const nbytes = this.dlDataType.numStorageBytes() * size;\n    const stack = this.lib.getOrAllocCallStack();\n\n    const tempOffset = stack.allocRawBytes(nbytes);\n    const tempPtr = stack.ptrFromOffset(tempOffset);\n    this.lib.checkCall(\n      (this.lib.exports.TVMArrayCopyToBytes as ctypes.FTVMArrayCopyToBytes)(\n        this.getHandle(),\n        tempPtr,\n        nbytes\n      )\n    );\n    const ret = this.lib.memory.loadRawBytes(tempPtr, nbytes);\n\n    this.lib.recycleCallStack(stack);\n    return ret;\n  }\n\n  /**\n   * Return a TypedArray copy of the NDArray, the specific type depends on\n   * the dtype of the NDArray.\n   * @returns The result array.\n   */\n  toArray(): Float32Array | Float64Array | Int32Array | Int8Array | Uint8Array {\n    const stype = this.dtype;\n    if (stype == \"float32\") {\n      return new Float32Array(this.toRawBytes().buffer);\n    } else if (stype == \"float64\") {\n      return new Float64Array(this.toRawBytes().buffer);\n    } else if (stype == \"int32\") {\n      return new Int32Array(this.toRawBytes().buffer);\n    } else if (stype == \"int8\") {\n      return new Int8Array(this.toRawBytes().buffer);\n    } else if (stype == \"uint8\") {\n      return new Uint8Array(this.toRawBytes().buffer);\n    } else {\n      throw new Error(\"Unsupported data type \" + this.dtype);\n    }\n  }\n\n  private getDLTensorFromArrayHandle(handle: Pointer): Pointer {\n    // Note: this depends on the NDArray C ABI.\n    // keep this function in case of ABI change.\n    return handle;\n  }\n}\n\n/**\n * Runtime Module.\n */\nexport class Module implements Disposable {\n  private handle: Pointer;\n  private lib: FFILibrary;\n  private makePackedFunc: (ptr: Pointer) => PackedFunc;\n\n  constructor(\n    handle: Pointer,\n    lib: FFILibrary,\n    makePackedFunc: (ptr: Pointer) => PackedFunc\n  ) {\n    this.handle = handle;\n    this.lib = lib;\n    this.makePackedFunc = makePackedFunc;\n  }\n\n  dispose(): void {\n    if (this.handle != 0) {\n      this.lib.checkCall(\n        (this.lib.exports.TVMModFree as ctypes.FTVMModFree)(this.handle)\n      );\n      this.handle = 0;\n    }\n  }\n\n  /**\n   * Get handle of module, check it is not null.\n   *\n   * @param requireNotNull require handle is not null.\n   * @returns The handle.\n   */\n  getHandle(requireNotNull: boolean = true): Pointer {\n    if (requireNotNull && this.handle == 0) {\n      throw Error(\"Module has already been disposed\");\n    }\n    return this.handle;\n  }\n\n  /**\n   * Get a function in the module.\n   * @param name The name of the function.\n   * @param queryImports Whether to also query imports\n   * @returns The result function.\n   */\n  getFunction(name: string, queryImports: boolean = true): PackedFunc {\n    if (this.handle == 0) {\n      throw Error(\"Module has already been disposed\");\n    }\n    const stack = this.lib.getOrAllocCallStack();\n    const nameOffset = stack.allocRawBytes(name.length + 1);\n    stack.storeRawBytes(nameOffset, StringToUint8Array(name));\n\n    const outOffset = stack.allocPtrArray(1);\n    const outPtr = stack.ptrFromOffset(outOffset);\n\n    stack.commitToWasmMemory(outOffset);\n\n    this.lib.checkCall(\n      (this.lib.exports.TVMModGetFunction as ctypes.FTVMModGetFunction)(\n        this.getHandle(),\n        stack.ptrFromOffset(nameOffset),\n        queryImports ? 1 : 0,\n        outPtr\n      )\n    );\n    const handle = this.lib.memory.loadPointer(outPtr);\n    this.lib.recycleCallStack(stack);\n    if (handle == 0) {\n      throw Error(\"Cannot find function \" + name);\n    }\n    const ret = this.makePackedFunc(handle);\n    return ret;\n  }\n\n  /**\n   * Import another module into the current runtime module.\n   * @param mod The module to be imported.\n   */\n  importModule(mod: Module): void {\n    this.lib.checkCall(\n      (this.lib.exports.TVMModImport as ctypes.FTVMModImport)(\n        this.getHandle(),\n        mod.getHandle()\n      )\n    );\n  }\n}\n\n/**\n * Generic object base\n */\nexport class TVMObject implements Disposable {\n  private handle: Pointer;\n  private lib: FFILibrary;\n  protected ctx: RuntimeContext;\n\n  constructor(\n    handle: Pointer,\n    lib: FFILibrary,\n    ctx: RuntimeContext\n  ) {\n    this.handle = handle;\n    this.lib = lib;\n    this.ctx = ctx;\n  }\n\n  dispose(): void {\n    if (this.handle != 0) {\n      this.lib.checkCall(\n        (this.lib.exports.TVMObjectFree as ctypes.FTVMObjectFree)(this.handle)\n      );\n      this.handle = 0;\n    }\n  }\n\n  /**\n   * Get handle of module, check it is not null.\n   *\n   * @param requireNotNull require handle is not null.\n   * @returns The handle.\n   */\n  getHandle(requireNotNull: boolean = true): Pointer {\n    if (requireNotNull && this.handle == 0) {\n      throw Error(\"Module has already been disposed\");\n    }\n    return this.handle;\n  }\n\n  /** get the type index of the object */\n  typeIndex(): number {\n    if (this.handle == 0) {\n      throw Error(\"The current Object has already been disposed\");\n    }\n    const stack = this.lib.getOrAllocCallStack();\n    const outOffset = stack.allocPtrArray(1);\n    const outPtr = stack.ptrFromOffset(outOffset);\n\n    this.lib.checkCall(\n      (this.lib.exports.TVMObjectGetTypeIndex as ctypes.FTVMObjectGetTypeIndex)(\n        this.getHandle(),\n        outPtr\n      )\n    );\n    const result = this.lib.memory.loadU32(outPtr);\n    this.lib.recycleCallStack(stack);\n    return result;\n  }\n\n  /** get the type key of the object */\n  typeKey(): string {\n    const type_index = this.typeIndex();\n    const stack = this.lib.getOrAllocCallStack();\n    const outOffset = stack.allocPtrArray(1);\n    const outPtr = stack.ptrFromOffset(outOffset);\n    this.lib.checkCall(\n      (this.lib.exports.TVMObjectTypeIndex2Key as ctypes.FTVMObjectTypeIndex2Key)(\n        type_index,\n        outPtr\n      )\n    );\n    const result = this.lib.memory.loadCString(\n      this.lib.memory.loadPointer(outPtr)\n    );\n    this.lib.recycleCallStack(stack);\n    return result;\n  }\n}\n\n/** Objectconstructor */\ntype FObjectConstructor = (handle: Pointer, lib: FFILibrary, ctx: RuntimeContext) => TVMObject;\n\n/** All possible object types. */\ntype TVMObjectBase = TVMObject | NDArray | Module | PackedFunc;\n\n/** Runtime array object. */\nexport class TVMArray extends TVMObject {\n  constructor(\n    handle: Pointer,\n    lib: FFILibrary,\n    ctx: RuntimeContext\n  ) {\n    super(handle, lib, ctx);\n  }\n\n  /**\n   * @returns the size of the array.\n   */\n  size(): number {\n    return this.ctx.arrayGetSize(this) as number;\n  }\n  /**\n   * Get index-th element of the array\n   * @param index the array index.\n   * @returns The element.\n   */\n  get(index: number): TVMObjectBase {\n    return this.ctx.arrayGetItem(this, new Scalar(index, \"int32\")) as TVMObjectBase;\n  }\n}\n\nexport const enum VMAllocatorKind {\n  NAIVE_ALLOCATOR = 1,\n  POOLED_ALLOCATOR = 2,\n}\n\n/**\n *  VirtualMachine Executor.\n *\n *  This is a thin wrapper of the underlying TVM module.\n *  you can also directly call set_input, run, and get_output\n *  of underlying module functions\n */\nexport class VirtualMachine implements Disposable {\n  private mod: Module;\n  /**\n   * Constructor\n   * @param mod The underlying module, need to be detached.\n   * @param device The main device ro run VM on.\n   */\n  constructor(mod: Module, device: DLDevice) {\n    this.mod = mod;\n    this.mod.getFunction(\"vm_initialization\")(\n      new Scalar(device.deviceType, \"int\"),\n      new Scalar(device.deviceId, \"int\"),\n      new Scalar(VMAllocatorKind.POOLED_ALLOCATOR, \"int\"),\n      // explicitly specify host device type\n      new Scalar(DeviceStrToEnum.cpu, \"int\"),\n      new Scalar(0, \"int\"),\n      new Scalar(VMAllocatorKind.POOLED_ALLOCATOR, \"int\"),\n    );\n  }\n\n  dispose(): void {\n    this.mod.dispose();\n  }\n  /**\n   * Get a function in the VM module.\n   * @param name The name of the function.\n   * @returns The result function.\n   */\n  getFunction(name: string): PackedFunc {\n    return this.mod.getFunction(name);\n  }\n\n  /**\n   * Get the internal module.\n   */\n  getInternalModule(): Module {\n    return this.mod;\n  }\n}\n\n/** Code used as the first argument of the async callback. */\nconst enum AyncCallbackCode {\n  kReturn = 4,\n  kException = 5,\n}\nexport interface NDArrayCacheEntry {\n  name: string;\n  shape: Array<number>;\n  dtype: string;\n  format: \"f32-to-bf16\" | \"raw\";\n  byteOffset: number;\n  nbytes: number;\n}\n\nexport interface NDArrayShardEntry {\n  dataPath: string;\n  format: \"raw-shard\";\n  nbytes: number;\n  records: Array<NDArrayCacheEntry>;\n}\n\nexport interface InitProgressReport {\n  type: 'init';\n  progress: number;\n  timeElapsed: number;\n  currentChunk: number;\n  totalChunks: number;\n  fetchedBytes: number;\n  totalBytes: number;\n}\n\nexport type InitProgressCallback = (report: InitProgressReport) => void;\n\n/**\n * TVM runtime instance.\n *\n * All objects(NDArray, Module, PackedFunc) returned by TVM runtim function call\n * and PackedFunc instance are tracked through a scope mechanism that will get\n * auto-released when we call EndScope.\n *\n * This is necessarily to be able to release the underlying WASM and WebGPU memory that\n * are not tracked through JS native garbage collection mechanism.\n *\n * This does mean that we have to get familar with the following functions:\n * - {@link beginScope}\n * - {@link endScope}\n * - {@link withNewScope}\n * - {@link attachToCurrentScope}\n * - {@link detachFromCurrentScope}\n */\nexport class Instance implements Disposable {\n  memory: Memory;\n  exports: Record<string, Function>;\n  cacheMetadata: Record<string, any> = {};\n  private lib: FFILibrary;\n  private env: Environment;\n  private objFactory: Map<number, FObjectConstructor>;\n  private ctx: RuntimeContext;\n  private initProgressCallback: Array<InitProgressCallback> = [];\n\n  /**\n   * Internal function(registered by the runtime)\n   */\n  private wasmCreateLibraryModule?: PackedFunc &\n    ((getFunc: PackedFunc, getGlobal: PackedFunc) => PackedFunc);\n\n  /**\n   * Constructor\n   *\n   * importObject can also be a {@link LibraryProvider} object,\n   * a WASI object, or an object containing wasmLibraryProvider field.\n   *\n   * @param wasmModule The input module or instance.\n   * @param importObject The imports to initialize the wasmInstance if it is not provided.\n   * @param wasmInstance Additional wasm instance argument for deferred construction.\n   * @param env Directly specified environment module.\n   *\n   * @see Please use the async version {@link instantiate} when targeting browsers.\n   */\n  constructor(\n    wasmModule: WebAssembly.Module,\n    importObject: Record<string, any> = {},\n    wasmInstance?: WebAssembly.Instance,\n    env?: Environment\n  ) {\n    if (wasmInstance instanceof WebAssembly.Instance) {\n      assert(\n        env instanceof Environment,\n        \"env must be provided when passing in instance\"\n      );\n    } else {\n      assert(env === undefined);\n      env = new Environment(importObject);\n      wasmInstance = new WebAssembly.Instance(wasmModule, env.imports);\n    }\n    env.start(wasmInstance);\n    this.env = env;\n    this.lib = new FFILibrary(wasmInstance, env.imports);\n    this.memory = this.lib.memory;\n    this.exports = this.lib.exports;\n    this.objFactory = new Map<number, ObjectConstructor>();\n    this.ctx = new RuntimeContext(\n      (name: string) => {\n        const autoAttachToScope = false;\n        // runtime context function do not auto-release.\n        return this.getGlobalFuncInternal(name, autoAttachToScope);\n      }\n    );\n    this.registerEnvGlobalPackedFuncs();\n    this.registerObjectFactoryFuncs();\n  }\n\n  /**\n   * Benchmark stable execution of the run function.\n   *\n   * @params run The run function\n   * @params dev The device to sync during each run.\n   * @number The number of times to compute the average.\n   * @repeat The number of times to repeat the run.\n   */\n  async benchmark(run: () => void, dev: DLDevice, number = 10, repeat = 1): Promise<number[]> {\n    // Skip first run as it can involve GPU warmup and module loading time.\n    const perf = compact.getPerformance();\n    const results = [];\n\n    // run with new scope\n    this.withNewScope(run);\n    await dev.sync();\n\n    for (let k = 0; k < repeat; ++k) {\n      const tstart = perf.now();\n      for (let i = 0; i < number; ++i) {\n        this.withNewScope(run);\n      }\n      await dev.sync();\n      const tend = perf.now();\n      results.push((tend - tstart) / number);\n    }\n    return results;\n  }\n\n  dispose(): void {\n    // order matters\n    // ctx release goes back into lib.\n    this.ctx.dispose();\n    this.lib.dispose();\n  }\n  /**\n   * Obtain the runtime information in readable format.\n   */\n  runtimeStatsText(): string {\n    if (this.lib.webGPUContext !== undefined) {\n      return this.lib.webGPUContext.runtimeStatsText();\n    } else {\n      return \"\";\n    }\n  }\n\n  /**\n   * Begin a new scope for tracking object disposal.\n   */\n  beginScope(): void {\n    this.ctx.beginScope();\n  }\n\n  /**\n   * End a scope and release all created TVM objects\n   * under the current scope.\n   *\n   * Exception: one can call {@link moveToParentScope} to move\n   * a value to parent scope.\n   */\n  endScope(): void {\n    this.ctx.endScope();\n  }\n\n  /**\n   * Perform action under a new scope.\n   *\n   * @param action The action function.\n   * @returns The result value.\n   *\n   * @note For action to return a valid value,\n   *       we will need to call {@link moveToParentScope}\n   *       for the objects that are created in the scope.\n   */\n  withNewScope<T>(action: () => T): T {\n    this.beginScope();\n    const val = action();\n    this.endScope();\n    return val;\n  }\n\n  /**\n   * Attach a detached obj to the auto-release pool of the current scope.\n   *\n   * @param obj The input obj.\n   * @note Normally user do not need to call this function explicitly, as\n   *       all library call return values are explicitly attached to\n   *       the current scope. You only need to do so when you call\n   *       {@link detachFromCurrentScope} to create a detached object.\n   */\n  attachToCurrentScope<T extends Disposable>(obj: T): T {\n    return this.ctx.attachToCurrentScope(obj);\n  }\n\n  /**\n   * Move obj's attachment to the parent scope.\n   *\n   * This function is useful to make sure objects are still\n   * alive when exit the current scope.\n   *\n   * @param obj The object to be moved.\n   * @returns The input obj.\n   */\n  moveToParentScope<T extends Disposable>(obj: T): T {\n    return this.ctx.moveToParentScope(obj);\n  }\n\n  /**\n   * Detach the object from the current scope\n   * so it won't be released via auto-release during endscope.\n   *\n   * User needs to either explicitly call obj.dispose(), or\n   * {@link attachToCurrentScope} to re-attach to the current scope.\n   *\n   * This function can be used to return values to the parent scope.\n   * @param obj The object.\n   */\n  detachFromCurrentScope<T extends Disposable>(obj: T): T {\n    return this.ctx.detachFromCurrentScope(obj);\n  }\n\n  /**\n   * Get system-wide library module in the wasm.\n   * System lib is a global module that contains self register functions in startup.\n   * @returns The system library module.\n   */\n  systemLib(): Module {\n    return this.ctx.getSysLib() as Module;\n  }\n  /**\n   * List all the global function names registered in the runtime.\n   * @returns The name list.\n   */\n  listGlobalFuncNames(): Array<string> {\n    const stack = this.lib.getOrAllocCallStack();\n\n    const outSizeOffset = stack.allocPtrArray(2);\n\n    const outSizePtr = stack.ptrFromOffset(outSizeOffset);\n    const outArrayPtr = stack.ptrFromOffset(\n      outSizeOffset + this.lib.sizeofPtr()\n    );\n\n    this.lib.checkCall(\n      (this.exports.TVMFuncListGlobalNames as ctypes.FTVMFuncListGlobalNames)(\n        outSizePtr,\n        outArrayPtr\n      )\n    );\n\n    const size = this.memory.loadI32(outSizePtr);\n    const array = this.memory.loadPointer(outArrayPtr);\n    const names: Array<string> = [];\n\n    for (let i = 0; i < size; ++i) {\n      names.push(\n        this.memory.loadCString(\n          this.memory.loadPointer(array + this.lib.sizeofPtr() * i)\n        )\n      );\n    }\n\n    this.lib.recycleCallStack(stack);\n    return names;\n  }\n\n  /**\n   * Register function to be global function in tvm runtime.\n   * @param name The name of the function.\n   * @param f function to be registered.\n   * @param override Whether overwrite function in existing registry.\n   */\n  registerFunc(\n    name: string,\n    func: PackedFunc | Function,\n    override = false\n  ): void {\n    this.withNewScope(() => {\n      const autoAttachToScope = true;\n      // packed func can be released once it is registered\n      const packedFunc = this.toPackedFuncInternal(func, autoAttachToScope);\n      const ioverride = override ? 1 : 0;\n\n      const stack = this.lib.getOrAllocCallStack();\n      const nameOffset = stack.allocRawBytes(name.length + 1);\n      stack.storeRawBytes(nameOffset, StringToUint8Array(name));\n      stack.commitToWasmMemory();\n\n      this.lib.checkCall(\n        (this.lib.exports.TVMFuncRegisterGlobal as ctypes.FTVMFuncRegisterGlobal)(\n          stack.ptrFromOffset(nameOffset),\n          packedFunc._tvmPackedCell.getHandle(),\n          ioverride\n        )\n      );\n      this.lib.recycleCallStack(stack);\n    });\n  }\n\n  /**\n   * Get global PackedFunc from the runtime.\n   * @param name The name of the function.\n   * @param autoAttachToScope Whether to track it via autoDispose\n   * @returns The result function.\n   */\n  getGlobalFunc(name: string): PackedFunc {\n    return this.getGlobalFuncInternal(name, true);\n  }\n\n  private getGlobalFuncInternal(name: string, autoAttachToScope: boolean = true): PackedFunc {\n    const stack = this.lib.getOrAllocCallStack();\n    const nameOffset = stack.allocRawBytes(name.length + 1);\n    stack.storeRawBytes(nameOffset, StringToUint8Array(name));\n    const outOffset = stack.allocPtrArray(1);\n    const outPtr = stack.ptrFromOffset(outOffset);\n\n    stack.commitToWasmMemory(outOffset);\n\n    this.lib.checkCall(\n      (this.exports.TVMFuncGetGlobal as ctypes.FTVMFuncGetGlobal)(\n        stack.ptrFromOffset(nameOffset),\n        outPtr\n      )\n    );\n    const handle = this.memory.loadPointer(outPtr);\n    this.lib.recycleCallStack(stack);\n    if (handle == 0) {\n      throw Error(\"Cannot find global function \" + name);\n    }\n    const ret = this.makePackedFunc(handle);\n    if (autoAttachToScope) this.ctx.attachToCurrentScope(ret);\n    return ret;\n  }\n\n  /**\n   * Check if func is PackedFunc.\n   *\n   * @param func The input.\n   * @returns The check result.\n   */\n  isPackedFunc(func: unknown): boolean {\n    // eslint-disable-next-line no-prototype-builtins\n    return typeof func == \"function\" && func.hasOwnProperty(\"_tvmPackedCell\");\n  }\n\n  /**\n   * Convert func to PackedFunc\n   *\n   * @param func Input function.\n   * @returns The converted function.\n   */\n  toPackedFunc(func: Function): PackedFunc {\n    return this.toPackedFuncInternal(func, true);\n  }\n\n  private toPackedFuncInternal(func: Function, autoAttachToScope: boolean): PackedFunc {\n    if (this.isPackedFunc(func)) return func as PackedFunc;\n    const ret = this.createPackedFuncFromCFunc(this.wrapJSFuncAsPackedCFunc(func));\n    if (autoAttachToScope) return this.ctx.attachToCurrentScope(ret);\n    return ret;\n  }\n\n  /**\n  * Setup a virtual machine module with given device.\n  *\n  * @param dev DLDevice the device.\n  * @returns The created virtual machime.\n  */\n  createVirtualMachine(dev: DLDevice): VirtualMachine {\n    const mod = this.ctx.detachFromCurrentScope(\n      this.systemLib().getFunction(\"vm_load_executable\")()\n    );\n    return this.ctx.attachToCurrentScope(\n      new VirtualMachine(mod, dev)\n    );\n  }\n\n  //-----------------------------------------------\n  // Native NDArray Cache Support\n  //-----------------------------------------------\n  /**\n   * Register a call back for fetch progress.\n  *\n   * @param cb the fetch progress callback.\n   */\n  registerInitProgressCallback(cb: InitProgressCallback) {\n    this.initProgressCallback.push(cb);\n  }\n\n  /**\n   * Get parameters in the form of prefix_i\n   *\n   * @param prefix The parameter prefix.\n   * @param numParams  Number of parameters.\n   * @returns\n   */\n  getParamsFromCache(prefix: string, numParams: number): TVMObject {\n    return (this.ctx.paramModuleFromCache(\n      prefix, new Scalar(numParams, \"int32\")) as Module).getFunction(\"get_params\")();\n  }\n\n  /**\n   * Get NDArray from cache.\n   * @param name  The name of array.\n   * @returns  The result.\n   */\n  ndarrayCacheGet(name: string): NDArray | undefined {\n    return this.ctx.arrayCacheGet(name);\n  }\n\n  /**\n   * Get NDArray from cache.\n   * @param name  The name of array.\n   * @returns  The result.\n   */\n  ndarrayCacheRemove(name: string): NDArray | undefined {\n    return this.ctx.arrayCacheRemove(name);\n  }\n\n  /**\n   * Update the ndarray cache.\n   * @param name The name of the array.\n   * @param arr The content.\n   */\n  ndarrayCacheUpdate(name: string, arr: NDArray, override: boolean = false) {\n    this.ctx.arrayCacheUpdate(name, arr, this.scalar(override ? 1 : 0, \"int32\"));\n  }\n\n  /**\n   * Update the ndarray cache.\n   * @param name The name of the array.\n   * @param arr The content.\n   */\n  ndarrayCacheClear() {\n    this.ctx.arrayCacheClear();\n  }\n\n  /**\n   * Fetch NDArray cache from url.\n   *\n   * @param ndarrayCacheUrl The cache url.\n   * @param device The device to be fetched to.\n   * @returns The meta data\n   */\n  async fetchNDArrayCache(ndarrayCacheUrl: string, device: DLDevice): Promise<any> {\n    const jsonUrl = new URL(\"ndarray-cache.json\", ndarrayCacheUrl).href;\n    const request = new Request(jsonUrl);\n    const cache = await caches.open(\"tvmjs\");\n    let result = await cache.match(request);\n    if (result === undefined) {\n      await cache.add(request);\n      result = await cache.match(request);\n    }\n    if (result === undefined) {\n      this.env.logger(\"Error: Cannot cache \" + jsonUrl + \", reloading will be slow\");\n      try {\n        result = await fetch(request);\n      } catch (err) {\n        this.env.logger(\"Cannot fetch \" + jsonUrl);\n      }\n    }\n    let list;\n    if (result instanceof Response) {\n      list = await result.json();\n    }\n    await this.fetchNDArrayCacheInternal(\n      ndarrayCacheUrl,\n      list[\"records\"] as Array<NDArrayShardEntry>, device);\n    this.cacheMetadata = { ...this.cacheMetadata, ...(list[\"metadata\"] as Record<string, any>) };\n  }\n\n  /**\n   * Fetch list of NDArray into the NDArrayCache.\n   *\n   * @param ndarrayCacheUrl The cache url.\n   * @param list The list of array data.\n   * @param device The device to store the data to.\n   */\n  private async fetchNDArrayCacheInternal(ndarrayCacheUrl: string, list: Array<NDArrayShardEntry>, device: DLDevice) {\n    const perf = compact.getPerformance();\n    let tstart = perf.now();\n\n    let totalBytes = 0;\n    for (let i = 0; i < list.length; ++i) {\n      totalBytes += list[i].nbytes;\n    };\n    let fetchedBytes = 0;\n    let timeElapsed = 0;\n\n    const reportCallback = (iter: number) => {\n      // report\n      for (let j = 0; j < this.initProgressCallback.length; ++j) {\n        this.initProgressCallback[j]({\n          type: 'init',\n          progress: fetchedBytes / totalBytes,\n          timeElapsed: timeElapsed,\n          currentChunk: iter,\n          totalChunks: list.length,\n          fetchedBytes,\n          totalBytes,\n        });\n      }\n    };\n\n    for (let j = 0; j < this.initProgressCallback.length; ++j) {\n      this.initProgressCallback[j]({\n        type: 'init',\n        progress: fetchedBytes / totalBytes,\n        timeElapsed: 0,\n        currentChunk: 0,\n        totalChunks: list.length,\n        fetchedBytes,\n        totalBytes,\n      });\n    }\n    const cache = await caches.open(\"tvmjs\");\n\n    for (let i = 0; i < list.length; ++i) {\n      reportCallback(i);\n      fetchedBytes += list[i].nbytes;\n      const dataUrl = new URL(list[i].dataPath, ndarrayCacheUrl).href;\n      const request = new Request(dataUrl);\n      let buffer;\n      try {\n        // use native cache\n        let result = await cache.match(request);\n        if (result === undefined) {\n          await cache.add(request);\n          result = await cache.match(request);\n        }\n        if (result == undefined) {\n          this.env.logger(\"Error: Cannot cache \" + dataUrl + \", reloading will be slow\");\n          result = await fetch(request);\n        }\n        buffer = await result.arrayBuffer();\n      } catch (err) {\n        this.env.logger(\"Error: Cannot fetch \" + dataUrl + \" err= \" + err);\n        throw err;\n      }\n      const shardRecords = list[i].records;\n      for (let j = 0; j < shardRecords.length; ++j) {\n        const rec = shardRecords[j];\n        const cpu_arr = this.withNewScope(() => {\n          return this.detachFromCurrentScope(\n            this.empty(rec.shape, rec.dtype, this.cpu())\n          )\n        });\n        const recSource = buffer.slice(rec.byteOffset, rec.byteOffset + rec.nbytes);\n        // first sync copy to cpu.\n        this.ctx.arrayDecodeStorage(cpu_arr, new Uint8Array(recSource), rec.format);\n        // then async stream into GPU if needed\n        if (device.deviceType == DeviceStrToEnum.cpu) {\n          this.ndarrayCacheUpdate(rec.name, cpu_arr, false);\n          cpu_arr.dispose();\n        } else {\n          // allocate a gpu arr and async copy to it.\n          const gpu_arr = this.withNewScope(() => {\n            return this.detachFromCurrentScope(\n              this.empty(rec.shape, rec.dtype, device)\n            )\n          });\n          gpu_arr.copyFrom(cpu_arr);\n          await device.sync();\n          this.ndarrayCacheUpdate(rec.name, gpu_arr, false);\n          cpu_arr.dispose();\n          gpu_arr.dispose();\n        }\n      }\n      timeElapsed = Math.ceil((perf.now() - tstart) / 1000);\n    }\n    reportCallback(list.length);\n  }\n\n  /**\n   * Convert dtype to {@link DLDataType}\n   *\n   * @param dtype The input dtype string or DLDataType.\n   * @returns The converted result.\n   */\n  toDLDataType(dtype: string | DLDataType): DLDataType {\n    if (dtype instanceof DLDataType) return dtype;\n    if (typeof dtype == \"string\") {\n      let pattern = dtype;\n      let code,\n        bits = 32,\n        lanes = 1;\n      if (pattern.substring(0, 5) == \"float\") {\n        pattern = pattern.substring(5, pattern.length);\n        code = DLDataTypeCode.Float;\n      } else if (pattern.substring(0, 3) == \"int\") {\n        pattern = pattern.substring(3, pattern.length);\n        code = DLDataTypeCode.Int;\n      } else if (pattern.substring(0, 4) == \"uint\") {\n        pattern = pattern.substring(4, pattern.length);\n        code = DLDataTypeCode.UInt;\n      } else if (pattern.substring(0, 6) == \"handle\") {\n        pattern = pattern.substring(5, pattern.length);\n        code = DLDataTypeCode.OpaqueHandle;\n        bits = 64;\n      } else {\n        throw new Error(\"Unknown dtype \" + dtype);\n      }\n\n      const arr = pattern.split(\"x\");\n      if (arr.length >= 1) {\n        const parsed = parseInt(arr[0]);\n        if (parsed + \"\" == arr[0]) {\n          bits = parsed;\n        }\n      }\n      if (arr.length >= 2) {\n        lanes = parseInt(arr[1]);\n      }\n      return new DLDataType(code, bits, lanes);\n    } else {\n      throw new Error(\"Unknown dtype \" + dtype);\n    }\n  }\n\n  /**\n   * Create a new {@link Scalar} that can be passed to a PackedFunc.\n   * @param value The number value.\n   * @param dtype The dtype string.\n   * @returns The created scalar.\n   */\n  scalar(value: number, dtype: string): Scalar {\n    return new Scalar(value, dtype);\n  }\n\n  /**\n   * Create a new {@link DLDevice}\n   * @param deviceType The device type.\n   * @param deviceId The device index.\n   * @returns The created device.\n   */\n  device(deviceType: number | string, deviceId = 0): DLDevice {\n    return new DLDevice(deviceType, deviceId, this.lib);\n  }\n\n  /**\n   * Create a new cpu {@link DLDevice}\n   * @param deviceId The device index.\n   */\n  cpu(deviceId = 0): DLDevice {\n    return this.device(\"cpu\", deviceId);\n  }\n\n  /**\n   * Create a new webgpu {@link DLDevice}\n   * @param deviceId The device index.\n   */\n  webgpu(deviceId = 0): DLDevice {\n    return this.device(\"webgpu\", deviceId);\n  }\n\n  /**\n   * Create an empty {@link NDArray} with given shape and dtype.\n   *\n   * @param shape The shape of the array.\n   * @param dtype The data type of the array.\n   * @param dev The device of the ndarray.\n   * @returns The created ndarray.\n   */\n  empty(\n    shape: Array<number> | number,\n    dtype: string | DLDataType = \"float32\",\n    dev: DLDevice = this.device(\"cpu\", 0)\n  ): NDArray {\n    dtype = this.toDLDataType(dtype);\n    shape = typeof shape == \"number\" ? [shape] : shape;\n\n    const stack = this.lib.getOrAllocCallStack();\n    const shapeOffset = stack.allocRawBytes(shape.length * SizeOf.I64);\n    for (let i = 0; i < shape.length; ++i) {\n      stack.storeI64(shapeOffset + i * SizeOf.I64, shape[i]);\n    }\n\n    const outOffset = stack.allocPtrArray(1);\n    const outPtr = stack.ptrFromOffset(outOffset);\n    stack.commitToWasmMemory(outOffset);\n\n    this.lib.checkCall(\n      (this.exports.TVMArrayAlloc as ctypes.FTVMArrayAlloc)(\n        stack.ptrFromOffset(shapeOffset),\n        shape.length,\n        dtype.code,\n        dtype.bits,\n        dtype.lanes,\n        dev.deviceType,\n        dev.deviceId,\n        outPtr\n      )\n    );\n    const ret = this.ctx.attachToCurrentScope(\n      new NDArray(this.memory.loadPointer(outPtr), false, this.lib, this.ctx)\n    );\n    this.lib.recycleCallStack(stack);\n    return ret;\n  }\n\n  /**\n   * Create am uniform {@link NDArray} with given shape.\n   *\n   * @param shape The shape of the array.\n   * @param low The low value.\n   * @param high The high value.\n   * @param dev The device of the ndarray.\n   * @returns The created ndarray.\n   */\n  uniform(\n    shape: Array<number>,\n    low: number,\n    high: number,\n    dev: DLDevice\n  ): NDArray {\n    const ret = this.empty(shape, \"float32\", dev);\n    const size = shape.reduce((a, b) => {\n      return a * b;\n    }, 1);\n    const scale = high - low;\n    const input = new Float32Array(size);\n    for (let i = 0; i < input.length; ++i) {\n      input[i] = low + Math.random() * scale;\n    }\n    return ret.copyFrom(input);\n  }\n\n  /**\n   * Sample index via top-p sampling.\n   *\n   * @param logits The input logits before normalization.\n   * @param temperature  The temperature factor, will take argmax if temperature = 0.0\n   * @param top_p The top_p\n   * @returns The sampled index.\n   */\n  sampleTopPFromLogits(logits: NDArray, temperature: number, top_p: number): number {\n    return this.ctx.sampleTopPFromLogits(logits, temperature, top_p, Math.random());\n  }\n\n  /**\n   * Bind canvas to the current WebGPU context\n   * @param canvas The canvas.\n   */\n  bindCanvas(canvas: HTMLCanvasElement) {\n    this.lib.webGPUContext?.bindCanvas(canvas);\n  }\n\n  /**\n   * Show image in canvas.\n   *\n   * @param dataRGBA Image array in height x width uint32 NDArray RGBA format on GPU.\n   */\n  showImage(dataRGBA: NDArray) {\n    if (dataRGBA.shape.length != 2) {\n      throw Error(\"Require a height x width uint32 NDArray in RGBA\" +\n        \"get shape=\" + dataRGBA.shape.toString() + \" instead.\"\n      );\n    }\n    if (dataRGBA.device.deviceType != DeviceStrToEnum.webgpu) {\n      throw new Error(\"Can only run showImage on WebGPU array, \" +\n        \"get \" + DeviceEnumToStr[dataRGBA.device.deviceType] + \" instead.\");\n    }\n    if (dataRGBA.dtype != \"uint32\") {\n      throw Error(\"Require a height x width uint32 NDArray in RGBA, \" +\n        \"get \" + dataRGBA.dtype + \" instead.\");\n    }\n    this.lib.webGPUContext?.drawImageFromBuffer(\n      dataRGBA.getDataPtr(), dataRGBA.shape[0], dataRGBA.shape[1]\n    );\n  }\n\n  /**\n   * Clear canvas\n   */\n  clearCanvas() {\n    this.lib.webGPUContext?.clearCanvas();\n  }\n\n  /**\n   * Create an tuple {@link TVMArray} input array.\n   *\n   * The input array can be passed to tvm runtime function\n   * and needs to b explicitly disposed.\n   *\n   * @param inputs The input array\n   * @returns The result array.\n   */\n  makeTVMArray(\n    inputs: Array<TVMObjectBase>\n  ): TVMArray {\n    return this.ctx.arrayMake(...inputs) as TVMArray;\n  }\n\n  /**\n   * Create a shape tuple to pass to runtime.\n   * @param shape The shape .\n   * @returns The created shape tuple.\n   */\n  makeShapeTuple(shape: Array<number>): TVMObject {\n    const shapeArray = shape.map((value) => new Scalar(value, \"int\"));\n    return this.ctx.makeShapeTuple(...shapeArray);\n  }\n  /**\n   * Get type index from type key.\n   * @param typeKey The type key.\n   * @returns The corresponding type index.\n   */\n  typeKey2Index(\n    typeKey: string\n  ): number {\n    const stack = this.lib.getOrAllocCallStack();\n    const typeKeyOffset = stack.allocRawBytes(typeKey.length + 1);\n    stack.storeRawBytes(typeKeyOffset, StringToUint8Array(typeKey));\n    const outOffset = stack.allocPtrArray(1);\n    const outPtr = stack.ptrFromOffset(outOffset);\n\n    stack.commitToWasmMemory(outOffset);\n\n    this.lib.checkCall(\n      (this.lib.exports.TVMObjectTypeKey2Index as ctypes.FTVMObjectTypeKey2Index)(\n        stack.ptrFromOffset(typeKeyOffset),\n        outPtr\n      )\n    );\n    const typeIndex = this.memory.loadU32(outPtr);\n    this.lib.recycleCallStack(stack);\n    return typeIndex;\n  }\n\n  /**\n   * Register an object constructor.\n   * @param typeKey The name of the function.\n   * @param func function to be registered.\n   * @param override Whether overwrite function in existing registry.\n   */\n  registerObjectConstructor(\n    typeKey: string,\n    func: FObjectConstructor,\n    override = false\n  ): void {\n    const typeIndex = this.typeKey2Index(typeKey);\n    if (this.objFactory.has(typeIndex)) {\n      if (!override) {\n        throw new Error(\"Type \" + typeKey + \" already registered\");\n      }\n    }\n    this.objFactory.set(typeIndex, func);\n  }\n  /**\n   * Register an asyncfunction to be global function in the server.\n   * @param name The name of the function.\n   * @param func function to be registered.\n   * @param override Whether overwrite function in existing registry.\n   *\n   * @note The async function will only be used for serving remote calls in the rpc.\n   */\n  registerAsyncServerFunc(\n    name: string,\n    func: Function,\n    override = false\n  ): void {\n    const asyncVariant = (...args: Array<any>): void => {\n      const fargs = args.slice(0, args.length - 1);\n      // need to keep it alive until callback is fulfilled.\n      const callback = this.detachFromCurrentScope(args[args.length - 1] as PackedFunc);\n      const promise: Promise<any> = func(...fargs);\n      promise.then((rv: any) => {\n        callback(this.scalar(AyncCallbackCode.kReturn, \"int32\"), rv);\n        callback.dispose();\n      });\n    };\n    this.registerFunc(\"__async.\" + name, asyncVariant, override);\n  }\n\n  /**\n   * Asynchrously load webgpu pipelines when possible.\n   * @param mod The input module.\n   */\n  async asyncLoadWebGPUPiplines(mod: Module): Promise<void> {\n    if (this.lib.webGPUContext == undefined) throw Error(\"WebGPU not initialied\");\n    const webgpuContext = this.lib.webGPUContext;\n\n    this.beginScope();\n    const fmap_str = mod.getFunction(\"webgpu.get_fmap\", true)() as string;\n    let fmap: Record<string, FunctionInfo> = JSON.parse(fmap_str);\n    const totalFuncs = fmap.length;\n    const fGetShader = this.detachFromCurrentScope(\n      mod.getFunction(\"webgpu.get_shader\")\n    );\n    const fUpdatePrebuild = this.detachFromCurrentScope(\n      mod.getFunction(\"webgpu.update_prebuild\")\n    );\n    this.endScope();\n\n    const perf = compact.getPerformance();\n    const tstart = perf.now();\n    let tlastReport = tstart;\n    let finishCounter = 0;\n    const fmapEntries = Object.entries(fmap);\n\n    let allEvents = Promise.resolve();\n\n    for (const [key, finfo] of fmapEntries) {\n      const code = fGetShader(key);\n      assert(key == finfo.name);\n      const event = webgpuContext.createShaderAsync(finfo, code).then((func: Function) => {\n        this.beginScope();\n        fUpdatePrebuild(key, func);\n        this.endScope();\n\n      }).then(() => {\n        finishCounter += 1;\n        const tend = perf.now();\n        const timeReportGap = 1000;\n        // skip report if gap is smaller than 1000\n        if ((tend - tlastReport) < 1000 && finishCounter != fmapEntries.length) {\n          return;\n        }\n        tlastReport = tend;\n        const timeElapsed = Math.ceil((perf.now() - tstart) / 1000);\n        // report\n        for (let j = 0; j < this.initProgressCallback.length; ++j) {\n          const progress = finishCounter / fmapEntries.length;\n          let text = \"Loading GPU shader modules[\" + finishCounter + \"/\" + fmapEntries.length + \"]: \";\n          text += Math.floor(progress * 100).toString() + \"% completed, \"\n          text += timeElapsed + \" secs elapsed.\";\n          // this.initProgressCallback[j]({\n          //   progress: progress,\n          //   timeElapsed: timeElapsed,\n          //   text: text\n          // });\n        }\n      });\n      allEvents = Promise.all([allEvents, event]).then(() => { });\n    }\n    await allEvents;\n    assert(finishCounter == fmapEntries.length);\n  }\n\n  /**\n   * Initialize webgpu in the runtime.\n   * @param device The given GPU device.\n   */\n  initWebGPU(device: GPUDevice): void {\n    const webGPUContext = new WebGPUContext(\n      this.memory, device\n    );\n    this.registerFunc(\"wasm.WebGPUDeviceAPI\", (name: string) => {\n      return webGPUContext.getDeviceAPI(name);\n    });\n    this.registerFunc(\"wasm.WebGPUCreateShader\", (info: string, code: string) => {\n      const finfo = JSON.parse(info) as FunctionInfo;\n      return webGPUContext.createShader(finfo, code);\n    });\n    this.registerAsyncServerFunc(\"wasm.WebGPUWaitForTasks\", async () => {\n      await webGPUContext.sync();\n    });\n    this.lib.webGPUContext = webGPUContext;\n  }\n\n  /** Register all object factory */\n  private registerObjectFactoryFuncs(): void {\n    this.registerObjectConstructor(\"Array\",\n      (handle: number, lib: FFILibrary, ctx: RuntimeContext) => {\n        return new TVMArray(handle, lib, ctx);\n      });\n  }\n\n  /** Register global packed functions needed by the backend to the env. */\n  private registerEnvGlobalPackedFuncs(): void {\n    // Register the timer function to enable the time_evaluator.\n    const perf = compact.getPerformance();\n\n    // Helper function to time the finvoke\n    const timeExecution = async (\n      finvoke: PackedFunc,\n      dev: DLDevice,\n      nstep: number,\n      repeat: number,\n      minRepeatMs: number,\n      limitZeroTimeIterations: number,\n      cooldownIntervalMs: number,\n      repeatsToCooldown: number\n    ): Promise<Uint8Array> => {\n      // detach and explicit dispose when tasks is fullfilled\n      // the promise will immediately return and we need to makesure\n      // finvoke do not get recycled.\n      this.ctx.detachFromCurrentScope(finvoke);\n\n      finvoke(this.scalar(1, \"int32\"));\n      await dev.sync();\n      const result = [];\n      let setupNumber: number = nstep;\n\n      for (let i = 0; i < repeat; ++i) {\n        let durationMs = 0.0;\n        let absoluteZeroTimes = 0;\n        do {\n          if (durationMs > 0.0) {\n            let golden_ratio = 1.618;\n            setupNumber = Math.floor(\n              Math.max(minRepeatMs / (durationMs / setupNumber) + 1, setupNumber * golden_ratio)\n            );\n          }\n          const tstart: number = perf.now();\n          finvoke(this.scalar(setupNumber, \"int32\"));\n          await dev.sync();\n          const tend: number = perf.now();\n\n          durationMs = tend - tstart;\n          if (durationMs == 0) {\n            absoluteZeroTimes++;\n          }\n        } while (durationMs < minRepeatMs && absoluteZeroTimes < limitZeroTimeIterations);\n        const speed = durationMs / setupNumber / 1000;\n        result.push(speed);\n        if (cooldownIntervalMs > 0.0 && (i % repeatsToCooldown) == 0) {\n          await new Promise(r => setTimeout(r, cooldownIntervalMs));\n        }\n      }\n      const ret = new Float64Array(result.length);\n      ret.set(result);\n\n      // dispose finvoke\n      finvoke.dispose();\n      return new Uint8Array(ret.buffer);\n    };\n\n    const addOne = async (x: number): Promise<number> => {\n      await new Promise(resolve => setTimeout(resolve, 100));\n      return x + 1;\n    };\n\n    this.registerAsyncServerFunc(\"wasm.TimeExecution\", timeExecution);\n    this.registerAsyncServerFunc(\"testing.asyncAddOne\", addOne);\n  }\n\n  private createPackedFuncFromCFunc(\n    func: ctypes.FTVMWasmPackedCFunc\n  ): PackedFunc {\n    let findex = this.env.packedCFuncTable.length;\n    if (this.env.packedCFuncTableFreeId.length != 0) {\n      findex = this.env.packedCFuncTableFreeId.pop() as number;\n    } else {\n      this.env.packedCFuncTable.push(undefined);\n    }\n    this.env.packedCFuncTable[findex] = func;\n\n    const stack = this.lib.getOrAllocCallStack();\n    const outOffset = stack.allocPtrArray(1);\n    const outPtr = stack.ptrFromOffset(outOffset);\n    this.lib.checkCall(\n      (this.exports\n        .TVMWasmFuncCreateFromCFunc as ctypes.FTVMWasmFuncCreateFromCFunc)(\n          findex,\n          outPtr\n        )\n    );\n    const ret = this.makePackedFunc(this.memory.loadPointer(outPtr));\n    this.lib.recycleCallStack(stack);\n    return ret;\n  }\n\n  /**\n   * Set packed function arguments into the location indicated by argsValue and argsCode.\n   * Allocate new temporary space from the stack if necessary.\n   *\n   * @parma stack The call stack\n   * @param args  The input arguments.\n   * @param argsValue The offset of argsValue.\n   * @param argsCode The offset of argsCode.\n   */\n  setPackedArguments(\n    stack: CachedCallStack,\n    args: Array<any>,\n    argsValue: PtrOffset,\n    argsCode: PtrOffset\n  ): void {\n    for (let i = 0; i < args.length; ++i) {\n      let val = args[i];\n      const tp = typeof val;\n      const valueOffset = argsValue + i * SizeOf.TVMValue;\n      const codeOffset = argsCode + i * SizeOf.I32;\n      if (val instanceof NDArray) {\n        if (!val.isView) {\n          stack.storePtr(valueOffset, val.getHandle());\n          stack.storeI32(codeOffset, ArgTypeCode.TVMNDArrayHandle);\n        } else {\n          stack.storePtr(valueOffset, val.getHandle());\n          stack.storeI32(codeOffset, ArgTypeCode.TVMDLTensorHandle);\n        }\n      } else if (val instanceof Scalar) {\n        if (val.dtype.startsWith(\"int\") || val.dtype.startsWith(\"uint\")) {\n          stack.storeI64(valueOffset, val.value);\n          stack.storeI32(codeOffset, ArgTypeCode.Int);\n        } else if (val.dtype.startsWith(\"float\")) {\n          stack.storeF64(valueOffset, val.value);\n          stack.storeI32(codeOffset, ArgTypeCode.Float);\n        } else {\n          assert(val.dtype == \"handle\", \"Expect handle\");\n          stack.storePtr(valueOffset, val.value);\n          stack.storeI32(codeOffset, ArgTypeCode.TVMOpaqueHandle);\n        }\n      } else if (val instanceof DLDevice) {\n        stack.storeI32(valueOffset, val.deviceType);\n        stack.storeI32(valueOffset + SizeOf.I32, val.deviceType);\n        stack.storeI32(codeOffset, ArgTypeCode.DLDevice);\n      } else if (tp == \"number\") {\n        stack.storeF64(valueOffset, val);\n        stack.storeI32(codeOffset, ArgTypeCode.Float);\n        // eslint-disable-next-line no-prototype-builtins\n      } else if (tp == \"function\" && val.hasOwnProperty(\"_tvmPackedCell\")) {\n        stack.storePtr(valueOffset, val._tvmPackedCell.getHandle());\n        stack.storeI32(codeOffset, ArgTypeCode.TVMPackedFuncHandle);\n      } else if (val === null || val == undefined) {\n        stack.storePtr(valueOffset, 0);\n        stack.storeI32(codeOffset, ArgTypeCode.Null);\n      } else if (tp == \"string\") {\n        stack.allocThenSetArgString(valueOffset, val);\n        stack.storeI32(codeOffset, ArgTypeCode.TVMStr);\n      } else if (val instanceof Uint8Array) {\n        stack.allocThenSetArgBytes(valueOffset, val);\n        stack.storeI32(codeOffset, ArgTypeCode.TVMBytes);\n      } else if (val instanceof Function) {\n        val = this.toPackedFuncInternal(val, false);\n        stack.tempArgs.push(val);\n        stack.storePtr(valueOffset, val._tvmPackedCell.getHandle());\n        stack.storeI32(codeOffset, ArgTypeCode.TVMPackedFuncHandle);\n      } else if (val instanceof Module) {\n        stack.storePtr(valueOffset, val.getHandle());\n        stack.storeI32(codeOffset, ArgTypeCode.TVMModuleHandle);\n      } else if (val instanceof TVMObject) {\n        stack.storePtr(valueOffset, val.getHandle());\n        stack.storeI32(codeOffset, ArgTypeCode.TVMObjectHandle);\n      } else {\n        throw new Error(\"Unsupported argument type \" + tp);\n      }\n    }\n  }\n\n  private wrapJSFuncAsPackedCFunc(func: Function): ctypes.FTVMWasmPackedCFunc {\n    const lib = this.lib;\n    return (\n      argValues: Pointer,\n      argCodes: Pointer,\n      nargs: number,\n      ret: Pointer,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      _handle: Pointer\n    ): number => {\n      const jsArgs = [];\n      // use scope to track js values.\n      this.ctx.beginScope();\n      for (let i = 0; i < nargs; ++i) {\n        const valuePtr = argValues + i * SizeOf.TVMValue;\n        const codePtr = argCodes + i * SizeOf.I32;\n        let tcode = lib.memory.loadI32(codePtr);\n\n        if (\n          tcode == ArgTypeCode.TVMObjectHandle ||\n          tcode == ArgTypeCode.TVMObjectRValueRefArg ||\n          tcode == ArgTypeCode.TVMPackedFuncHandle ||\n          tcode == ArgTypeCode.TVMNDArrayHandle ||\n          tcode == ArgTypeCode.TVMModuleHandle\n        ) {\n          lib.checkCall(\n            (lib.exports.TVMCbArgToReturn as ctypes.FTVMCbArgToReturn)(\n              valuePtr,\n              codePtr\n            )\n          );\n        }\n        tcode = lib.memory.loadI32(codePtr);\n        jsArgs.push(this.retValueToJS(valuePtr, tcode, true));\n      }\n\n      const rv = func(...jsArgs);\n      // recycle all js object value in function unless we want to retain them.\n      this.ctx.endScope();\n\n      if (rv !== undefined && rv !== null) {\n        const stack = lib.getOrAllocCallStack();\n        const valueOffset = stack.allocRawBytes(SizeOf.TVMValue);\n        const codeOffset = stack.allocRawBytes(SizeOf.I32);\n        this.setPackedArguments(stack, [rv], valueOffset, codeOffset);\n        const valuePtr = stack.ptrFromOffset(valueOffset);\n        const codePtr = stack.ptrFromOffset(codeOffset);\n        stack.commitToWasmMemory();\n        lib.checkCall(\n          (lib.exports.TVMCFuncSetReturn as ctypes.FTVMCFuncSetReturn)(\n            ret,\n            valuePtr,\n            codePtr,\n            1\n          )\n        );\n        lib.recycleCallStack(stack);\n      }\n      return 0;\n    };\n  }\n\n  private makePackedFunc(handle: Pointer): PackedFunc {\n    const cell = new PackedFuncCell(handle, this.lib);\n\n    const packedFunc = (...args: any): any => {\n      const stack = this.lib.getOrAllocCallStack();\n\n      const valueOffset = stack.allocRawBytes(SizeOf.TVMValue * args.length);\n      const tcodeOffset = stack.allocRawBytes(SizeOf.I32 * args.length);\n\n      this.setPackedArguments(stack, args, valueOffset, tcodeOffset);\n\n      const rvalueOffset = stack.allocRawBytes(SizeOf.TVMValue);\n      const rcodeOffset = stack.allocRawBytes(SizeOf.I32);\n      const rvaluePtr = stack.ptrFromOffset(rvalueOffset);\n      const rcodePtr = stack.ptrFromOffset(rcodeOffset);\n\n      // commit to wasm memory, till rvalueOffset (the return value don't need to be committed)\n      stack.commitToWasmMemory(rvalueOffset);\n\n      this.lib.checkCall(\n        (this.exports.TVMFuncCall as ctypes.FTVMFuncCall)(\n          cell.getHandle(),\n          stack.ptrFromOffset(valueOffset),\n          stack.ptrFromOffset(tcodeOffset),\n          args.length,\n          rvaluePtr,\n          rcodePtr\n        )\n      );\n\n      const ret = this.retValueToJS(rvaluePtr, this.memory.loadI32(rcodePtr), false);\n      this.lib.recycleCallStack(stack);\n      return ret;\n    };\n    // Attach attributes to the function type.\n    // This is because javascript do not allow us to overload call.\n    const ret: any = packedFunc;\n    ret.dispose = (): void => {\n      cell.dispose();\n    };\n    ret._tvmPackedCell = cell;\n    return ret as PackedFunc;\n  }\n\n  /**\n   * Creaye return value of the packed func. The value us auto-tracked for dispose.\n   * @param rvaluePtr The location of rvalue\n   * @param tcode     The type code.\n   * @param callbackArg Whether it is being used in callbackArg.\n   * @returns The JS value.\n   */\n  private retValueToJS(rvaluePtr: Pointer, tcode: number, callbackArg: boolean): any {\n    switch (tcode) {\n      case ArgTypeCode.Int:\n      case ArgTypeCode.UInt:\n        return this.memory.loadI64(rvaluePtr);\n      case ArgTypeCode.Float:\n        return this.memory.loadF64(rvaluePtr);\n      case ArgTypeCode.TVMOpaqueHandle: {\n        return this.memory.loadPointer(rvaluePtr);\n      }\n      case ArgTypeCode.TVMNDArrayHandle: {\n        return this.ctx.attachToCurrentScope(\n          new NDArray(this.memory.loadPointer(rvaluePtr), false, this.lib, this.ctx)\n        );\n      }\n      case ArgTypeCode.TVMDLTensorHandle: {\n        assert(callbackArg);\n        // no need to attach as we are only looking at view\n        return new NDArray(this.memory.loadPointer(rvaluePtr), true, this.lib, this.ctx);\n      }\n      case ArgTypeCode.TVMPackedFuncHandle: {\n        return this.ctx.attachToCurrentScope(\n          this.makePackedFunc(this.memory.loadPointer(rvaluePtr))\n        );\n      }\n      case ArgTypeCode.TVMModuleHandle: {\n        return this.ctx.attachToCurrentScope(\n          new Module(\n            this.memory.loadPointer(rvaluePtr),\n            this.lib,\n            (ptr: Pointer) => {\n              return this.ctx.attachToCurrentScope(this.makePackedFunc(ptr));\n            }\n          )\n        );\n      }\n      case ArgTypeCode.TVMObjectHandle: {\n        const obj = new TVMObject(\n          this.memory.loadPointer(rvaluePtr),\n          this.lib,\n          this.ctx\n        );\n        const func = this.objFactory.get(obj.typeIndex())\n        if (func != undefined) {\n          return this.ctx.attachToCurrentScope(\n            func(obj.getHandle(), this.lib, this.ctx)\n          );\n        } else {\n          return this.ctx.attachToCurrentScope(obj);\n        }\n      }\n      case ArgTypeCode.Null: return undefined;\n      case ArgTypeCode.DLDevice: {\n        const deviceType = this.memory.loadI32(rvaluePtr);\n        const deviceId = this.memory.loadI32(rvaluePtr + SizeOf.I32);\n        return this.device(deviceType, deviceId);\n      }\n      case ArgTypeCode.TVMStr: {\n        const ret = this.memory.loadCString(this.memory.loadPointer(rvaluePtr));\n        return ret;\n      }\n      case ArgTypeCode.TVMBytes: {\n        return this.memory.loadTVMBytes(this.memory.loadPointer(rvaluePtr));\n      }\n      default:\n        throw new Error(\"Unsupported return type code=\" + tcode);\n    }\n  }\n}\n\n/**\n * Asynchrously instantiate a new {@link Instance}.\n *\n * importObject can also be a {@link LibraryProvider} object,\n * a WASI object, or an object containing wasmLibraryProvider field.\n * We can take benefit of syslib implementations from the Emscripten\n * by passing its generated js Module as the imports.\n *\n * @param bufferSource The source to be compiled.\n * @param importObject The import objects.\n * @param logger The system logger.\n */\nexport function instantiate(\n  bufferSource: ArrayBuffer,\n  importObject: Record<string, any> = {},\n  logger: (msg: string) => void = console.log\n): Promise<Instance> {\n  const env = new Environment(importObject, logger);\n\n  return WebAssembly.instantiate(bufferSource, env.imports).then(\n    (result: WebAssembly.WebAssemblyInstantiatedSource): Instance => {\n      return new Instance(result.module, {}, result.instance, env);\n    }\n  );\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport { detectGPUDevice, instantiate } from \"../tvm\";\nimport { InitProgressCallback } from \"../tvm/runtime\";\nimport { Conversation, GenerateTextCallback, GenerateTextRequest, ModelInitConfig } from \"../types/modelApi\";\n\nexport class LLMInstance {\n  config: ModelInitConfig;\n  tvm: any;\n  tokenizer: any;\n  model: any;\n  spp: any;\n  processing: boolean;\n\n  constructor(config: ModelInitConfig, sentencePieceProcessor: any) {\n    this.config = config;\n    this.tvm = undefined;\n    this.tokenizer = undefined;\n    this.model = undefined;\n    this.spp = sentencePieceProcessor;\n    this.processing = false;\n  }\n\n  isInitialized() {\n    return this.model != undefined;\n  }\n\n  async init(cb: InitProgressCallback = console.log) {\n    if (this.model) {\n      return;\n    }\n    const wasmSource = await (await fetch(this.config.wasmUrl)).arrayBuffer();\n    this.tvm = await instantiate(\n      new Uint8Array(wasmSource),\n      //@ts-ignore\n      new EmccWASI(),\n      console.log,\n    );\n    try {\n      const output = await detectGPUDevice();\n      if (output !== undefined) {\n        this.tvm.initWebGPU(output.device);\n      } else {\n        throw Error(\"This browser env do not support WebGPU\");\n      }\n    } catch (err: any) {\n      throw Error(\"Find an error initializing WebGPU: \" + err.toString());\n    }\n    this.tvm.registerInitProgressCallback(cb);\n    await this.tvm.fetchNDArrayCache(this.config.cacheUrl, this.tvm.webgpu());\n\n    this.tokenizer = await this.spp()(this.config.tokenizerUrl);\n    this.model = this.tvm.withNewScope(() => {\n      return new LLMInstanceScope(\n        this.tvm,\n        this.tokenizer,\n        this.config.maxWindowSize\n      );\n    });\n    return this.model.init();\n  }\n\n  async generate(request: GenerateTextRequest, cb: GenerateTextCallback = console.log) {\n    if (this.processing) {\n      return;\n    }\n    this.processing = true;\n    await this.model.generate(request, cb);\n    this.processing = false;\n  }\n}\n\nexport class LLMInstanceScope {\n  tvm: any;\n  tokenizer: any;\n  maxWindowSize: number;\n  device: any;\n  vm: any;\n  encoding: any;\n  decoding: any;\n  params: any;\n  bosTokenId: number;\n  eosTokenId: number;\n  fclearKVCaches: any;\n  kvCache: any;\n  fcreateCache: any;\n  logitsOnCPU: any;\n  kvCacheLength: number;\n  lastMessageId: string;\n\n  constructor(tvm: any, tokenizer: any, maxWindowSize = 2048) {\n    this.tvm = tvm;\n    this.tokenizer = tokenizer;\n\n    this.bosTokenId = 1;\n    this.eosTokenId = 2;\n\n    this.maxWindowSize = maxWindowSize;\n\n    this.device = this.tvm.webgpu();\n\n    this.vm = this.tvm.detachFromCurrentScope(\n      this.tvm.createVirtualMachine(this.device)\n    );\n    this.encoding = this.tvm.detachFromCurrentScope(\n      this.vm.getFunction(\"encoding\")\n    );\n    this.decoding = this.tvm.detachFromCurrentScope(\n      this.vm.getFunction(\"decoding\")\n    );\n    this.params = this.tvm.detachFromCurrentScope(\n      this.tvm.getParamsFromCache(\"param\", this.tvm.cacheMetadata.ParamSize)\n    );\n    const fcreateCache = this.vm.getFunction(\"create_kv_cache\");\n    this.fclearKVCaches = this.tvm.detachFromCurrentScope(\n      this.tvm.getGlobalFunc(\"vm.builtin.attention_kv_cache_array_clear\")\n    );\n\n    // use extern config for now\n    this.kvCache = this.tvm.detachFromCurrentScope(fcreateCache());\n    // fill with pad token\n    this.logitsOnCPU = undefined;\n\n    this.kvCacheLength = 0;\n    this.lastMessageId = \"\";\n  }\n\n  async init() {\n    await this.tvm.asyncLoadWebGPUPiplines(this.vm.getInternalModule());\n  }\n\n  async getTokensFromStart(conversation: Conversation, maxTokens: number) {\n    this.clearKVCache();\n    const tokens = [];\n\n    for (let i = conversation.messages.length - 1; i >= 0; i--) {\n      const message = conversation.messages[i];\n      const text = `${message.role}: ${message.text}\\n`;\n      const messageTokens = await this.tokenizer.encodeIds(text);\n      if (\n        tokens.length + messageTokens.length + maxTokens >\n        this.maxWindowSize\n      ) {\n        break;\n      }\n      tokens.unshift(...(await this.tokenizer.encodeIds(text)));\n    }\n    tokens.unshift(\n      ...(await this.tokenizer.encodeIds(conversation.systemPrompt))\n    );\n    tokens.unshift(this.bosTokenId);\n\n    return tokens;\n  }\n\n  async getTokens(conversation: Conversation, maxTokens: number) {\n    // Case 1. Attention Cache is empty, start from beginning\n    // Case 2. Attention Cache is not empty, but the last message we processed is not in the cache, start from beginning\n    // Case 3. Attention Cache is not empty, and the last message we processed is in the cache, start from the next message\n    // Case 4. Attention Cache is not empty, and the last message we processed is in the cache, but the cache is too long, start from beginning\n    if (this.kvCacheLength == 0) {\n      // Case 1\n      return await this.getTokensFromStart(conversation, maxTokens);\n    }\n\n    // Calculate the index of the last message we processed\n    let startMsgIdx = 0;\n    for (let i = conversation.messages.length - 1; i >= 0; i--) {\n      if (conversation.messages[i].id == this.lastMessageId) {\n        startMsgIdx = i + 1;\n        break;\n      }\n    }\n\n    if (startMsgIdx == 0) {\n      // Case 2\n      return await this.getTokensFromStart(conversation, maxTokens);\n    }\n\n    const tokens = [this.eosTokenId];\n    for (let i = startMsgIdx; i < conversation.messages.length; i++) {\n      const message = conversation.messages[i];\n      const text = `${message.role}: ${message.text}`;\n      const messageTokens = await this.tokenizer.encodeIds(text);\n      if (\n        tokens.length + messageTokens.length + maxTokens >\n        this.maxWindowSize\n      ) {\n        // Case 4\n        return await this.getTokensFromStart(conversation, maxTokens);\n      }\n      tokens.push(...(await this.tokenizer.encodeIds(text)));\n    }\n\n    // Case 3\n    return tokens;\n  }\n\n  async generate(request: GenerateTextRequest, cb: GenerateTextCallback) {\n    const { conversation, maxTokens, assistantRoleName, stopTexts } = request;\n    const tokens = await this.getTokens(conversation, maxTokens);\n    tokens.push(...(await this.tokenizer.encodeIds(`${assistantRoleName}:`)));\n    console.log(\"debug: \", await this.tokenizer.decodeIds(tokens));\n\n    const inputTokenLength = tokens.length;\n    let outputText = \"\";\n    let tstart = 0,\n      tend = 0, step = 0;\n\n    const id = uuidv4();\n    for (; step < maxTokens; step++) {\n      this.tvm.beginScope();\n      tstart = performance.now();\n      var input;\n      if (step == 0) {\n        input = this.tvm.empty([1, tokens.length], \"int32\", this.device);\n        input.copyFrom(tokens);\n      } else {\n        input = this.tvm.empty([1, 1], \"int32\", this.device);\n        input.copyFrom(tokens.slice(tokens.length - 1));\n      }\n      const logits = this.tvm.detachFromCurrentScope(\n        this.forward(input, this.kvCacheLength + inputTokenLength + step)\n      );\n      this.tvm.endScope();\n      const nextToken = await this.sampleTokenFromLogits(logits);\n      logits.dispose();\n\n      tokens.push(nextToken);\n      const outputTokens = tokens.slice(inputTokenLength);\n      outputText = this.tokenizer.decodeIds(outputTokens);\n      tend = performance.now();\n      if (nextToken == this.eosTokenId) break;\n      const stopPos = outputText.lastIndexOf(\"</s>\");\n      if (stopPos != -1) {\n        outputText = outputText.substring(0, stopPos);\n        break;\n      }\n      let stop = false;\n      for (let i = 0; i < stopTexts.length; i++) {\n        if (outputText.endsWith(stopTexts[i])) {\n          outputText = outputText.substring(\n            0,\n            outputText.length - stopTexts[i].length\n          );\n          stop = true;\n          break;\n        }\n      }\n      if (stop) break;\n      if (step != 0) {\n        cb({\n          requestId: id,\n          step: step,\n          outputText,\n          stats: {\n            totalDecodingSeconds: (tend - tstart) / 1000,\n            totalDecodedTokens: tokens.length - inputTokenLength,\n            totalEncodedTokens: inputTokenLength,\n          },\n          isFinished: false,\n        });\n      }\n    }\n    this.kvCacheLength += tokens.length - 1;\n    this.lastMessageId = id;\n\n    cb({\n      requestId: id,\n      outputText,\n      step: step,\n      stats: {\n        totalDecodingSeconds: (tend - tstart) / 1000,\n        totalDecodedTokens: tokens.length - inputTokenLength,\n        totalEncodedTokens: inputTokenLength,\n      },\n      isFinished: true,\n    });\n  }\n\n  dispose() {\n    // note: tvm instance is not owned by this class\n    this.params.dispose();\n    this.decoding.dispose();\n    this.encoding.dispose();\n    this.vm.dispose();\n    this.kvCache.dispose();\n    this.fclearKVCaches.dispose();\n    if (this.logitsOnCPU != undefined) {\n      this.logitsOnCPU.dispose();\n    }\n  }\n\n  clearKVCache() {\n    this.fclearKVCaches(this.kvCache);\n    this.kvCacheLength = 0;\n    this.lastMessageId = \"\";\n  }\n\n  forward(inputs: any, curPos: number) {\n    this.tvm.beginScope();\n    var retValue;\n    const seqLenShape = this.tvm.makeShapeTuple([curPos]);\n    if (inputs.shape[1] > 1) {\n      retValue = this.encoding(inputs, seqLenShape, this.kvCache, this.params);\n    } else {\n      retValue = this.decoding(inputs, seqLenShape, this.kvCache, this.params);\n    }\n    const logits = this.tvm.detachFromCurrentScope(retValue.get(0));\n    this.tvm.endScope();\n    this.tvm.attachToCurrentScope(logits);\n    return logits;\n  }\n\n  // NOTE: caller must call device.sync()\n  updateLogitsOnCPU(logits: any) {\n    if (this.logitsOnCPU == undefined) {\n      this.logitsOnCPU = this.tvm.detachFromCurrentScope(\n        this.tvm.empty(logits.shape, logits.dtype, this.tvm.cpu())\n      );\n    } else {\n      if (logits.shape[0] != this.logitsOnCPU.shape[0]) {\n        throw Error(\"We expect the size of logits to remain unchanged\");\n      }\n    }\n    this.logitsOnCPU.copyFrom(logits);\n  }\n\n  async sampleTokenFromLogits(logits: any, temperature = 0.8, top_p = 0.95) {\n    this.tvm.beginScope();\n    this.updateLogitsOnCPU(logits);\n    this.tvm.endScope();\n    await this.device.sync();\n    return this.tvm.sampleTopPFromLogits(this.logitsOnCPU, temperature, top_p);\n  }\n}\n"],"names":["SizeOf","ArgTypeCode","compact.getPerformance","ret","uuidv4"],"mappings":"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"}